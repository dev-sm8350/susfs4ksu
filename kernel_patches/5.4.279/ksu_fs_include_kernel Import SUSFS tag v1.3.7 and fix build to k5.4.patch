From 1e0ae4be0ab101a8f4473b4c17f50539e303ac72 Mon Sep 17 00:00:00 2001
From: Celica Sylphil <kamikitakomaric@protonmail.com>
Date: Mon, 15 Jul 2024 21:55:27 +0800
Subject: [PATCH] ksu/fs/include/kernel/mm: Import SUSFS tag v1.3.7 and fix
 build to k5.4

ref: https://gitlab.com/simonpunk/susfs4ksu

Change-Id: 7ef6c364c74e3ba3f674560382a1f592e568581c
Signed-off-by: TogoFire <togofire@mailfence.com>
Co-Authored-By: simonpunk <16465163+simonpunk@users.noreply.github.com>
---
 drivers/staging/ksu/Kconfig         |   81 ++
 drivers/staging/ksu/Makefile        |   39 +
 drivers/staging/ksu/core_hook.c     |  210 ++++
 drivers/staging/ksu/kernel_compat.c |   10 +
 drivers/staging/ksu/kernel_compat.h |    1 +
 drivers/staging/ksu/ksu.c           |    8 +
 drivers/staging/ksu/selinux/rules.c |    5 +
 fs/Makefile                         |    7 +-
 fs/internal.h                       |    5 +
 fs/namei.c                          |  118 +++
 fs/open.c                           |   46 +
 fs/proc/base.c                      |   96 ++
 fs/proc/task_mmu.c                  |   28 +
 fs/proc_namespace.c                 |   50 +
 fs/readdir.c                        |    9 +
 fs/stat.c                           |   13 +
 fs/susfs.c                          | 1427 +++++++++++++++++++++++++++
 include/linux/susfs.h               |  216 ++++
 kernel/sys.c                        |    7 +
 mm/memfd.c                          |   11 +
 20 files changed, 2385 insertions(+), 2 deletions(-)
 create mode 100644 fs/susfs.c
 create mode 100644 include/linux/susfs.h

diff --git a/drivers/staging/ksu/Kconfig b/drivers/staging/ksu/Kconfig
index cdf8b33826c2a..2996da345faa2 100644
--- a/drivers/staging/ksu/Kconfig
+++ b/drivers/staging/ksu/Kconfig
@@ -16,4 +16,85 @@ config KSU_DEBUG
 	help
 	  Enable KernelSU debug mode.
 
+config KSU_SUSFS
+    bool "KernelSU addon - SUSFS"
+    depends on KSU
+    default y
+    help
+      Patch and Enable SUSFS to kernel with KernelSU
+
+config KSU_SUSFS_SUS_PATH
+    bool "Enable to hide suspicious path"
+    depends on KSU_SUSFS
+    default y
+    help
+      Allow hiding the existence of user-defined file/directory from various system calls
+
+config KSU_SUSFS_SUS_MOUNT
+    bool "Enable to hide suspicious mounts"
+    depends on KSU_SUSFS
+    default y
+    help
+      Allow hiding the user-defined mount paths from /proc/self/[mounts|mountinfo|mountstat]
+
+config KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+    bool "Enable to re-order mount id and parent mount id in mountinfo (experimental)"
+    depends on KSU_SUSFS_SUS_MOUNT
+    default y
+    help
+      - Enable this option will automatically and completely re-order the mount id and parent mount id in /proc/self/mountinfo
+      - The actual mnt_id/parent_mnt_id is not changed in kernel, only reflects on /proc/self/mountinfo
+      - You should not enable this if the mnt_id on your device is already not in order by default
+      - Moreover, be careful this feature may cause unknown system crashes / random reboot / bootloop on different kernels or devices, further testing is needed.
+      - Requires KSU_SUSFS_SUS_MOUNT to be ON
+
+config KSU_SUSFS_SUS_KSTAT
+    bool "Enable to spoof suspicious kstat"
+    depends on KSU_SUSFS
+    default y
+    help
+      Allow spoofing the kstat of user-defined file/directory
+
+config KSU_SUSFS_SUS_MAPS
+    bool "Enable to spoof suspicious maps"
+    depends on KSU_SUSFS
+    default y
+    help
+      Allow spoofing the user-defined mappings in /proc/self/[maps|smaps|map_files]
+
+config KSU_SUSFS_SUS_PROC_FD_LINK
+    bool "Enable to spoof suspicous symbolic links (experimental)"
+    depends on KSU_SUSFS
+    default y
+    help
+      Allow spoofing the user-defined symbolic link in /proc/self/fd/
+
+config KSU_SUSFS_SUS_MEMFD
+    bool "Enable to hide or spoof suspicous memfd (experimental)"
+    depends on KSU_SUSFS
+    default y
+    help
+      Allow preventing the user-defined memfd name from being created
+
+config KSU_SUSFS_TRY_UMOUNT
+    bool "Enable to use ksu's try_umount"
+    depends on KSU_SUSFS
+    default y
+    help
+      Allow using ksu's umount to umount other user-defined mount paths prior to ksu's default umount paths
+
+config KSU_SUSFS_SPOOF_UNAME
+    bool "Enable to spoof uname"
+    depends on KSU_SUSFS
+    default y
+    help
+      Allow spoofing the string returned by uname syscall to user-defined string
+
+config KSU_SUSFS_ENABLE_LOG
+    bool "Enable logging susfs log to kernel"
+    depends on KSU_SUSFS
+    default y
+    help
+      Allow logging susfs log to kernel, uncheck it to completely disable all susfs log
+
 endmenu
diff --git a/drivers/staging/ksu/Makefile b/drivers/staging/ksu/Makefile
index 2a048de319ff8..97a11961b5d3d 100644
--- a/drivers/staging/ksu/Makefile
+++ b/drivers/staging/ksu/Makefile
@@ -58,4 +58,43 @@ endif
 ccflags-y += -Wno-implicit-function-declaration -Wno-strict-prototypes -Wno-int-conversion -Wno-gcc-compat
 ccflags-y += -Wno-declaration-after-statement -Wno-unused-function
 
+ifeq ($(shell test -e $(srctree)/fs/susfs.c; echo $$?),0)
+ifdef KSU_SUSFS
+ccflags-y += -DKSU_SUSFS
+endif
+ifdef KSU_SUSFS_SUS_PATH
+ccflags-y += -DKSU_SUSFS_SUS_PATH
+endif
+ifdef KSU_SUSFS_SUS_MOUNT
+ccflags-y += -DKSU_SUSFS_SUS_MOUNT
+endif
+ifdef KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+ccflags-y += -DKSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+endif
+ifdef KSU_SUSFS_SUS_KSTAT
+ccflags-y += -DKSU_SUSFS_SUS_KSTAT
+endif
+ifdef KSU_SUSFS_SUS_MAPS
+ccflags-y += -DKSU_SUSFS_SUS_MAPS
+endif
+ifdef KSU_SUSFS_SUS_PROC_FD_LINK
+ccflags-y += -DKSU_SUSFS_SUS_PROC_FD_LINK
+endif
+ifdef KSU_SUSFS_SUS_MEMFD
+ccflags-y += -DKSU_SUSFS_SUS_MEMFD
+endif
+ifdef KSU_SUSFS_TRY_UMOUNT
+ccflags-y += -DKSU_SUSFS_TRY_UMOUNT
+endif
+ifdef KSU_SUSFS_SPOOF_UNAME
+ccflags-y += -DKSU_SUSFS_SPOOF_UNAME
+endif
+ifdef KSU_SUSFS_ENABLE_LOG
+ccflags-y += -DKSU_SUSFS_ENABLE_LOG
+endif
+else
+$(info -- You have not integrate susfs in your kernel.)
+$(info -- Read: https://gitlab.com/simonpunk/susfs4ksu)
+endif
+
 # Keep a new line here!! Because someone may append config
diff --git a/drivers/staging/ksu/core_hook.c b/drivers/staging/ksu/core_hook.c
index 0e569dd794668..18b5466dc2393 100644
--- a/drivers/staging/ksu/core_hook.c
+++ b/drivers/staging/ksu/core_hook.c
@@ -48,6 +48,10 @@
 #include "throne_tracker.h"
 #include "kernel_compat.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 static bool ksu_module_mounted = false;
 
 extern int handle_sepolicy(unsigned long arg3, void __user *arg4);
@@ -384,6 +388,207 @@ int ksu_handle_prctl(int option, unsigned long arg2, unsigned long arg3,
 		return 0;
 	}
 
+#ifdef CONFIG_KSU_SUSFS
+	if (current_uid().val == 0) {
+		int error = 0;
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+		if (arg2 == CMD_SUSFS_ADD_SUS_PATH) {
+			if (!ksu_access_ok((void __user*)arg3, sizeof(struct st_susfs_sus_path))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_PATH -> arg3 is not accessible\n");
+				return 0;
+			}
+			if (!ksu_access_ok((void __user*)arg5, sizeof(error))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_PATH -> arg5 is not accessible\n");
+				return 0;
+			}
+			error = susfs_add_sus_path((struct st_susfs_sus_path __user*)arg3);
+			pr_info("susfs: CMD_SUSFS_ADD_SUS_PATH -> ret: %d\n", error);
+			copy_to_user((void __user*)arg5, &error, sizeof(error));
+			return 0;
+		}
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+		if (arg2 == CMD_SUSFS_ADD_SUS_MOUNT) {
+			if (!ksu_access_ok((void __user*)arg3, sizeof(struct st_susfs_sus_mount))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_MOUNT -> arg3 is not accessible\n");
+				return 0;
+			}
+			if (!ksu_access_ok((void __user*)arg5, sizeof(error))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_MOUNT -> arg5 is not accessible\n");
+				return 0;
+			}
+			error = susfs_add_sus_mount((struct st_susfs_sus_mount __user*)arg3);
+			pr_info("susfs: CMD_SUSFS_ADD_SUS_MOUNT -> ret: %d\n", error);
+			copy_to_user((void __user*)arg5, &error, sizeof(error));
+			return 0;
+		}
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
+		if (arg2 == CMD_SUSFS_ADD_SUS_KSTAT) {
+			if (!ksu_access_ok((void __user*)arg3, sizeof(struct st_susfs_sus_kstat))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_KSTAT -> arg3 is not accessible\n");
+				return 0;
+			}
+			if (!ksu_access_ok((void __user*)arg5, sizeof(error))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_KSTAT -> arg5 is not accessible\n");
+				return 0;
+			}
+			error = susfs_add_sus_kstat((struct st_susfs_sus_kstat __user*)arg3);
+			pr_info("susfs: CMD_SUSFS_ADD_SUS_KSTAT -> ret: %d\n", error);
+			copy_to_user((void __user*)arg5, &error, sizeof(error));
+			return 0;
+		}
+		if (arg2 == CMD_SUSFS_UPDATE_SUS_KSTAT) {
+			if (!ksu_access_ok((void __user*)arg3, sizeof(struct st_susfs_sus_kstat))) {
+				pr_err("susfs: CMD_SUSFS_UPDATE_SUS_KSTAT -> arg3 is not accessible\n");
+				return 0;
+			}
+			if (!ksu_access_ok((void __user*)arg5, sizeof(error))) {
+				pr_err("susfs: CMD_SUSFS_UPDATE_SUS_KSTAT -> arg5 is not accessible\n");
+				return 0;
+			}
+			error = susfs_update_sus_kstat((struct st_susfs_sus_kstat __user*)arg3);
+			pr_info("susfs: CMD_SUSFS_UPDATE_SUS_KSTAT -> ret: %d\n", error);
+			copy_to_user((void __user*)arg5, &error, sizeof(error));
+			return 0;
+		}
+		if (arg2 == CMD_SUSFS_ADD_SUS_KSTAT_STATICALLY) {
+			if (!ksu_access_ok((void __user*)arg3, sizeof(struct st_susfs_sus_kstat))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_KSTAT_STATICALLY -> arg3 is not accessible\n");
+				return 0;
+			}
+			if (!ksu_access_ok((void __user*)arg5, sizeof(error))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_KSTAT_STATICALLY -> arg5 is not accessible\n");
+				return 0;
+			}
+			error = susfs_add_sus_kstat((struct st_susfs_sus_kstat __user*)arg3);
+			pr_info("susfs: CMD_SUSFS_ADD_SUS_KSTAT_STATICALLY -> ret: %d\n", error);
+			copy_to_user((void __user*)arg5, &error, sizeof(error));
+			return 0;
+        }
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+		if (arg2 == CMD_SUSFS_ADD_SUS_MAPS) {
+			if (!ksu_access_ok((void __user*)arg3, sizeof(struct st_susfs_sus_maps))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_MAPS -> arg3 is not accessible\n");
+				return 0;
+			}
+			if (!ksu_access_ok((void __user*)arg5, sizeof(error))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_MAPS -> arg5 is not accessible\n");
+				return 0;
+			}
+			error = susfs_add_sus_maps((struct st_susfs_sus_maps __user*)arg3);
+			pr_info("susfs: CMD_SUSFS_ADD_SUS_MAPS -> ret: %d\n", error);
+			copy_to_user((void __user*)arg5, &error, sizeof(error));
+			return 0;
+		}
+		if (arg2 == CMD_SUSFS_UPDATE_SUS_MAPS) {
+			if (!ksu_access_ok((void __user*)arg3, sizeof(struct st_susfs_sus_maps))) {
+				pr_err("susfs: CMD_SUSFS_UPDATE_SUS_MAPS -> arg3 is not accessible\n");
+				return 0;
+			}
+			if (!ksu_access_ok((void __user*)arg5, sizeof(error))) {
+				pr_err("susfs: CMD_SUSFS_UPDATE_SUS_MAPS -> arg5 is not accessible\n");
+				return 0;
+			}
+			error = susfs_update_sus_maps((struct st_susfs_sus_maps __user*)arg3);
+			pr_info("susfs: CMD_SUSFS_UPDATE_SUS_MAPS -> ret: %d\n", error);
+			copy_to_user((void __user*)arg5, &error, sizeof(error));
+			return 0;
+		}
+		if (arg2 == CMD_SUSFS_ADD_SUS_MAPS_STATICALLY) {
+			if (!ksu_access_ok((void __user*)arg3, sizeof(struct st_susfs_sus_maps))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_MAPS_STATICALLY -> arg3 is not accessible\n");
+				return 0;
+			}
+			if (!ksu_access_ok((void __user*)arg5, sizeof(error))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_MAPS_STATICALLY -> arg5 is not accessible\n");
+				return 0;
+			}
+			error = susfs_add_sus_maps((struct st_susfs_sus_maps __user*)arg3);
+			pr_info("susfs: CMD_SUSFS_ADD_SUS_MAPS_STATICALLY -> ret: %d\n", error);
+			copy_to_user((void __user*)arg5, &error, sizeof(error));
+			return 0;
+		}
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+#ifdef CONFIG_KSU_SUSFS_SUS_PROC_FD_LINK
+		if (arg2 == CMD_SUSFS_ADD_SUS_PROC_FD_LINK) {
+			if (!ksu_access_ok((void __user*)arg3, sizeof(struct st_susfs_sus_proc_fd_link))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_PROC_FD_LINK -> arg3 is not accessible\n");
+				return 0;
+			}
+			if (!ksu_access_ok((void __user*)arg5, sizeof(error))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_PROC_FD_LINK -> arg5 is not accessible\n");
+				return 0;
+			}
+			error = susfs_add_sus_proc_fd_link((struct st_susfs_sus_proc_fd_link __user*)arg3);
+			pr_info("susfs: CMD_SUSFS_ADD_SUS_PROC_FD_LINK -> ret: %d\n", error);
+			copy_to_user((void __user*)arg5, &error, sizeof(error));
+			return 0;
+		}
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_PROC_FD_LINK
+#ifdef CONFIG_KSU_SUSFS_SUS_MEMFD
+		if (arg2 == CMD_SUSFS_ADD_SUS_MEMFD) {
+			if (!ksu_access_ok((void __user*)arg3, sizeof(struct st_susfs_sus_memfd))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_MEMFD -> arg3 is not accessible\n");
+				return 0;
+			}
+			if (!ksu_access_ok((void __user*)arg5, sizeof(error))) {
+				pr_err("susfs: CMD_SUSFS_ADD_SUS_MEMFD -> arg5 is not accessible\n");
+				return 0;
+			}
+			error = susfs_add_sus_memfd((struct st_susfs_sus_memfd __user*)arg3);
+			pr_info("susfs: CMD_SUSFS_ADD_SUS_MEMFD -> ret: %d\n", error);
+			copy_to_user((void __user*)arg5, &error, sizeof(error));
+			return 0;
+		}
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_MEMFD
+#ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
+		if (arg2 == CMD_SUSFS_ADD_TRY_UMOUNT) {
+			if (!ksu_access_ok((void __user*)arg3, sizeof(struct st_susfs_try_umount))) {
+				pr_err("susfs: CMD_SUSFS_ADD_TRY_UMOUNT -> arg3 is not accessible\n");
+				return 0;
+			}
+			if (!ksu_access_ok((void __user*)arg5, sizeof(error))) {
+				pr_err("susfs: CMD_SUSFS_ADD_TRY_UMOUNT -> arg5 is not accessible\n");
+				return 0;
+			}
+			error = susfs_add_try_umount((struct st_susfs_try_umount __user*)arg3);
+			pr_info("susfs: CMD_SUSFS_ADD_TRY_UMOUNT -> ret: %d\n", error);
+			copy_to_user((void __user*)arg5, &error, sizeof(error));
+			return 0;
+		}
+#endif //#ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
+#ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
+		if (arg2 == CMD_SUSFS_SET_UNAME) {
+			if (!ksu_access_ok((void __user*)arg3, sizeof(struct st_susfs_uname))) {
+				pr_err("susfs: CMD_SUSFS_SET_UNAME -> arg3 is not accessible\n");
+				return 0;
+			}
+			if (!ksu_access_ok((void __user*)arg5, sizeof(error))) {
+				pr_err("susfs: CMD_SUSFS_SET_UNAME -> arg5 is not accessible\n");
+				return 0;
+			}
+			error = susfs_set_uname((struct st_susfs_uname __user*)arg3);
+			pr_info("susfs: CMD_SUSFS_SET_UNAME -> ret: %d\n", error);
+			copy_to_user((void __user*)arg5, &error, sizeof(error));
+			return 0;
+		}
+#endif //#ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
+#ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
+		if (arg2 == CMD_SUSFS_ENABLE_LOG) {
+			if (arg3 != 0 && arg3 != 1) {
+				pr_err("susfs: CMD_SUSFS_ENABLE_LOG -> arg3 can only be 0 or 1\n");
+				return 0;
+			}
+			susfs_set_log(arg3);
+			copy_to_user((void __user*)arg5, &error, sizeof(error));
+			return 0;
+		}
+#endif //#ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
+	}
+#endif //#ifdef CONFIG_KSU_SUSFS
+
 	// all other cmds are for 'root manager'
 	if (!from_manager) {
 		return 0;
@@ -544,6 +749,11 @@ int ksu_handle_setuid(struct cred *new, const struct cred *old)
 		current->pid);
 #endif
 
+#ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
+	// susfs come first, and lastly umount by ksu, make sure umount in reversed order
+	susfs_try_umount(new_uid.val);
+#endif
+
 	// fixme: use `collect_mounts` and `iterate_mount` to iterate all mountpoint and
 	// filter the mountpoint whose target is `/data/adb`
 	try_umount("/system", true, 0);
diff --git a/drivers/staging/ksu/kernel_compat.c b/drivers/staging/ksu/kernel_compat.c
index b242bc6373987..0ec3df624f94f 100644
--- a/drivers/staging/ksu/kernel_compat.c
+++ b/drivers/staging/ksu/kernel_compat.c
@@ -77,6 +77,16 @@ void ksu_android_ns_fs_check()
 	task_unlock(current);
 }
 
+int ksu_access_ok(const void *addr, unsigned long size) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+    /* For kernels before 5.0.0, pass the type argument to access_ok. */
+    return access_ok(VERIFY_READ, addr, size);
+#else
+    /* For kernels 5.0.0 and later, ignore the type argument. */
+    return access_ok(addr, size);
+#endif
+}
+
 struct file *ksu_filp_open_compat(const char *filename, int flags, umode_t mode)
 {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0) || defined(CONFIG_IS_HW_HISI)
diff --git a/drivers/staging/ksu/kernel_compat.h b/drivers/staging/ksu/kernel_compat.h
index ba9981857fd1d..34050e73d7900 100644
--- a/drivers/staging/ksu/kernel_compat.h
+++ b/drivers/staging/ksu/kernel_compat.h
@@ -29,6 +29,7 @@ extern struct key *init_session_keyring;
 #endif
 
 extern void ksu_android_ns_fs_check();
+extern int ksu_access_ok(const void *addr, unsigned long size);
 extern struct file *ksu_filp_open_compat(const char *filename, int flags,
 					 umode_t mode);
 extern ssize_t ksu_kernel_read_compat(struct file *p, void *buf, size_t count,
diff --git a/drivers/staging/ksu/ksu.c b/drivers/staging/ksu/ksu.c
index b35ee8c46cbdd..6fbfb0c15cc50 100644
--- a/drivers/staging/ksu/ksu.c
+++ b/drivers/staging/ksu/ksu.c
@@ -11,6 +11,10 @@
 #include "ksu.h"
 #include "throne_tracker.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 static struct workqueue_struct *ksu_workqueue;
 
 bool ksu_queue_work(struct work_struct *work)
@@ -49,6 +53,10 @@ int __init kernelsu_init(void)
 	pr_alert("*************************************************************");
 #endif
 
+#ifdef CONFIG_KSU_SUSFS
+	susfs_init();
+#endif
+
 	ksu_core_init();
 
 	ksu_workqueue = alloc_ordered_workqueue("kernelsu_work_queue", 0);
diff --git a/drivers/staging/ksu/selinux/rules.c b/drivers/staging/ksu/selinux/rules.c
index 339ace2439f5d..8d3118e3e4285 100644
--- a/drivers/staging/ksu/selinux/rules.c
+++ b/drivers/staging/ksu/selinux/rules.c
@@ -130,6 +130,11 @@ void apply_kernelsu_rules()
     ksu_allow(db, "system_server", KERNEL_SU_DOMAIN, "process", "getpgid");
     ksu_allow(db, "system_server", KERNEL_SU_DOMAIN, "process", "sigkill");
 
+#ifdef CONFIG_KSU_SUSFS
+	// Allow umount in zygote process without installing zygisk
+	ksu_allow(db, "zygote", "labeledfs", "filesystem", "unmount");
+#endif
+
 	rcu_read_unlock();
 }
 
diff --git a/fs/Makefile b/fs/Makefile
index 145e53fbef754..2f396948d5ee4 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -14,8 +14,11 @@ obj-y :=	open.o read_write.o file_table.o super.o \
 		attr.o bad_inode.o file.o filesystems.o namespace.o \
 		seq_file.o xattr.o libfs.o fs-writeback.o \
 		pnode.o splice.o sync.o utimes.o d_path.o \
-		stack.o fs_struct.o statfs.o fs_pin.o nsfs.o \
-		fs_types.o fs_context.o fs_parser.o fsopen.o
+		stack.o fs_struct.o statfs.o fs_pin.o nsfs.o
+
+obj-$(CONFIG_KSU_SUSFS) += susfs.o
+
+obj-y +=	fs_types.o fs_context.o fs_parser.o fsopen.o
 
 ifeq ($(CONFIG_BLOCK),y)
 obj-y +=	buffer.o block_dev.o direct-io.o mpage.o
diff --git a/fs/internal.h b/fs/internal.h
index d1201cdcc9fc9..ffd909a640b90 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -89,6 +89,11 @@ extern int __mnt_want_write_file(struct file *);
 extern void __mnt_drop_write_file(struct file *);
 
 extern void dissolve_on_fput(struct vfsmount *);
+
+#ifdef CONFIG_KSU_SUSFS
+int path_umount(struct path *path, int flags);
+#endif
+
 /*
  * fs_struct.c
  */
diff --git a/fs/namei.c b/fs/namei.c
index a9834a54b5175..8e0b77f577db9 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -46,6 +46,10 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/namei.h>
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 /* [Feb-1997 T. Schoebel-Theuer]
  * Fundamental changes in the pathname lookup mechanisms (namei)
  * were necessary because of omirr.  The reason is that omirr needs
@@ -3569,6 +3573,13 @@ struct file *do_filp_open(int dfd, struct filename *pathname,
 	int flags = op->lookup_flags;
 	struct file *filp;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	int error;
+	if (susfs_sus_path_by_filename(pathname, &error, SYSCALL_FAMILY_ALL_ENOENT)) {
+		return ERR_PTR(error);
+	}
+#endif
+
 	set_nameidata(&nd, dfd, pathname);
 	filp = path_openat(&nd, op, flags | LOOKUP_RCU);
 	if (unlikely(filp == ERR_PTR(-ECHILD)))
@@ -3757,6 +3768,19 @@ long do_mknodat(int dfd, const char __user *filename, umode_t mode,
 	int error;
 	unsigned int lookup_flags = 0;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(filename);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_MKNOD);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	error = may_mknod(mode);
 	if (error)
 		return error;
@@ -3836,6 +3860,19 @@ long do_mkdirat(int dfd, const char __user *pathname, umode_t mode)
 	int error;
 	unsigned int lookup_flags = LOOKUP_DIRECTORY;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(pathname);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_MKDIRAT);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 retry:
 	dentry = user_path_create(dfd, pathname, &path, lookup_flags);
 	if (IS_ERR(dentry))
@@ -3911,6 +3948,21 @@ long do_rmdir(int dfd, const char __user *pathname)
 	struct qstr last;
 	int type;
 	unsigned int lookup_flags = 0;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(pathname);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_RMDIR);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+	error = 0;
+#endif
+
 retry:
 	name = filename_parentat(dfd, getname(pathname), lookup_flags,
 				&path, &last, &type);
@@ -4042,6 +4094,17 @@ long do_unlinkat(int dfd, struct filename *name)
 	struct inode *inode = NULL;
 	struct inode *delegated_inode = NULL;
 	unsigned int lookup_flags = 0;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	int status;
+
+	status = susfs_sus_path_by_filename(name, &error, SYSCALL_FAMILY_UNLINKAT);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 retry:
 	name = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);
 	if (IS_ERR(name))
@@ -4149,6 +4212,19 @@ long do_symlinkat(const char __user *oldname, int newdfd,
 	struct path path;
 	unsigned int lookup_flags = 0;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(newname);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_SYMLINKAT_NEWNAME);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	from = getname(oldname);
 	if (IS_ERR(from))
 		return PTR_ERR(from);
@@ -4280,6 +4356,27 @@ int do_linkat(int olddfd, const char __user *oldname, int newdfd,
 	int how = 0;
 	int error;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(oldname);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_LINKAT_OLDNAME);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+
+	fname = getname_safe(newname);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_LINKAT_NEWNAME);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	if ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0)
 		return -EINVAL;
 	/*
@@ -4562,6 +4659,27 @@ static int do_renameat2(int olddfd, const char __user *oldname, int newdfd,
 	bool should_retry = false;
 	int error;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(oldname);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_RENAMEAT2_OLDNAME);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+
+	fname = getname_safe(newname);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_RENAMEAT2_NEWNAME);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
 		return -EINVAL;
 
diff --git a/fs/open.c b/fs/open.c
index 5cfa75053f3d1..5ed752c4f088d 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -35,6 +35,10 @@
 
 #include "internal.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,
 	struct file *filp)
 {
@@ -123,6 +127,18 @@ long do_sys_truncate(const char __user *pathname, loff_t length)
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
 	struct path path;
 	int error;
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(pathname);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_ALL_ENOENT);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
 
 	if (length < 0)	/* sorry, but loff_t says... */
 		return -EINVAL;
@@ -362,6 +378,22 @@ long do_faccessat(int dfd, const char __user *filename, int mode)
 	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
 #endif
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+	int error;
+#endif
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	fname = getname_safe(filename);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_ALL_ENOENT);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
 
@@ -463,6 +495,20 @@ int ksys_chdir(const char __user *filename)
 	struct path path;
 	int error;
 	unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(filename);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_ALL_ENOENT);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 retry:
 	error = user_path_at(AT_FDCWD, filename, lookup_flags, &path);
 	if (error)
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 861a6366d46c9..f6f19ee07cc23 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -101,6 +101,10 @@
 
 #include "../../lib/kstrtox.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 /* NOTE:
  *	Implementing inode permission operations in /proc is almost
  *	certainly an error.  Permission checks need to happen during
@@ -1733,6 +1737,15 @@ static int do_proc_readlink(struct path *path, char __user *buffer, int buflen)
 	char *pathname;
 	int len;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	struct mm_struct *mm;
+	struct vm_area_struct *vma;
+	struct file *vma_file;
+	struct dentry *vma_dentry;
+	struct inode *vma_inode;
+	unsigned long ino;
+#endif
+
 	if (!tmp)
 		return -ENOMEM;
 
@@ -1744,6 +1757,39 @@ static int do_proc_readlink(struct path *path, char __user *buffer, int buflen)
 
 	if (len > buflen)
 		len = buflen;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PROC_FD_LINK
+	if (!susfs_is_sus_proc_fd_link_list_empty()) {
+		if (susfs_sus_proc_fd_link(pathname, len))
+			goto orig_flow;
+	}
+#endif
+
+
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	if (!susfs_is_sus_maps_list_empty()) {
+		mm = current->mm;
+		down_read(&mm->mmap_sem);
+		for (vma = mm->mmap; vma; vma = vma->vm_next) {
+			if (vma->vm_file) {
+				vma_file = vma->vm_file;
+				vma_dentry = vma_file->f_path.dentry;
+				if (vma_dentry == path->dentry) {
+					vma_inode = file_inode(vma_file);
+					ino = vma_inode->i_ino;
+					susfs_sus_map_files_readlink(ino, pathname);
+					break;
+				}
+			}
+		}
+		up_read(&mm->mmap_sem);
+	}
+#endif
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PROC_FD_LINK
+orig_flow:
+#endif
+
 	if (copy_to_user(buffer, pathname, len))
 		len = -EFAULT;
  out:
@@ -2148,6 +2194,9 @@ struct map_files_info {
 	unsigned long	start;
 	unsigned long	end;
 	fmode_t		mode;
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	int susfs_action;
+#endif
 };
 
 /*
@@ -2208,6 +2257,10 @@ static struct dentry *proc_map_files_lookup(struct inode *dir,
 	struct dentry *result;
 	struct mm_struct *mm;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	int ret = 0;
+#endif
+
 	result = ERR_PTR(-ENOENT);
 	task = get_proc_task(dir);
 	if (!task)
@@ -2234,6 +2287,23 @@ static struct dentry *proc_map_files_lookup(struct inode *dir,
 	if (!vma)
 		goto out_no_vma;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	if (vma->vm_file) {
+		ret = susfs_sus_map_files_instantiate(vma);
+		if (ret == 1) {
+			if (vma->vm_file->f_mode & FMODE_WRITE) {
+				vma->vm_file->f_mode &= ~FMODE_WRITE;
+			}
+			goto orig_flow;
+		}
+		if (ret == 2) {
+			result = ERR_PTR(-ENOENT);
+			goto out_no_vma; 
+		}
+	}
+orig_flow:
+#endif
+
 	if (vma->vm_file)
 		result = proc_map_files_instantiate(dentry, task,
 				(void *)(unsigned long)vma->vm_file->f_mode);
@@ -2265,6 +2335,10 @@ proc_map_files_readdir(struct file *file, struct dir_context *ctx)
 	struct map_files_info *p;
 	int ret;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	int susfs_ret = 0;
+#endif
+
 	genradix_init(&fa);
 
 	ret = -ENOENT;
@@ -2319,6 +2393,12 @@ proc_map_files_readdir(struct file *file, struct dir_context *ctx)
 		p->start = vma->vm_start;
 		p->end = vma->vm_end;
 		p->mode = vma->vm_file->f_mode;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+		struct map_files_info info;
+		susfs_ret = susfs_sus_map_files_instantiate(vma);
+		info.susfs_action = susfs_ret;
+#endif
 	}
 	up_read(&mm->mmap_sem);
 	mmput(mm);
@@ -2329,12 +2409,28 @@ proc_map_files_readdir(struct file *file, struct dir_context *ctx)
 
 		p = genradix_ptr(&fa, i);
 		len = snprintf(buf, sizeof(buf), "%lx-%lx", p->start, p->end);
+
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+		if (p->susfs_action == SUSFS_MAP_FILES_ACTION_REMOVE_WRITE_PERM) {
+			if (p->mode & FMODE_WRITE) {
+					p->mode &= ~FMODE_WRITE;
+			}
+		} else if (p->susfs_action == SUSFS_MAP_FILES_ACTION_HIDE_DENTRY) {
+			goto skip_proc_fill_cache;
+		}
+#endif
+
 		if (!proc_fill_cache(file, ctx,
 				      buf, len,
 				      proc_map_files_instantiate,
 				      task,
 				      (void *)(unsigned long)p->mode))
 			break;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+skip_proc_fill_cache:
+#endif
+
 		ctx->pos++;
 	}
 
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index 62e7afc397d00..a26f7ff0906d1 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -28,6 +28,10 @@
 #include <asm/tlbflush.h>
 #include "internal.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 #define SEQ_PUT_DEC(str, val) \
 		seq_put_decimal_ull_width(m, str, (val) << (PAGE_SHIFT-10), 8)
 void task_mem(struct seq_file *m, struct mm_struct *mm)
@@ -503,6 +507,10 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma)
 	unsigned long start, end;
 	dev_t dev = 0;
 	const char *name = NULL;
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	char *out_name;
+	int ret = 0;
+#endif
 
 	if (file) {
 		struct inode *inode = file_inode(vma->vm_file);
@@ -513,9 +521,29 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma)
 
 	start = vma->vm_start;
 	end = vma->vm_end;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	out_name = kmalloc(SUSFS_MAX_LEN_PATHNAME, GFP_KERNEL);
+	if (!out_name)
+		goto orig_flow;
+	ret = susfs_sus_maps(ino, end - start, &ino, &dev, &flags, &pgoff, vma, out_name);
+
+orig_flow:
+#endif
+
 	if (show_vma_header_prefix(m, start, end, flags, pgoff, dev, ino))
 		return;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	if (ret == 2) {
+		seq_pad(m, ' ');
+		seq_puts(m, out_name);
+		seq_putc(m, '\n');
+		kfree(out_name);
+		return;
+	}
+	kfree(out_name);
+#endif
 	/*
 	 * Print the dentry name for named mappings, and a
 	 * special [heap] marker for the heap:
diff --git a/fs/proc_namespace.c b/fs/proc_namespace.c
index 5b8d065fa83cc..dc6ba954ba50e 100644
--- a/fs/proc_namespace.c
+++ b/fs/proc_namespace.c
@@ -18,6 +18,10 @@
 #include "pnode.h"
 #include "internal.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 static __poll_t mounts_poll(struct file *file, poll_table *wait)
 {
 	struct seq_file *m = file->private_data;
@@ -102,6 +106,11 @@ static int show_vfsmnt(struct seq_file *m, struct vfsmount *mnt)
 	struct super_block *sb = mnt_path.dentry->d_sb;
 	int err;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+	if (susfs_sus_mount(mnt, &p->root))
+		return 0;
+#endif
+
 	if (sb->s_op->show_devname) {
 		err = sb->s_op->show_devname(m, mnt_path.dentry);
 		if (err)
@@ -138,8 +147,31 @@ static int show_mountinfo(struct seq_file *m, struct vfsmount *mnt)
 	struct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };
 	int err;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+	int out_mnt_id = 0, out_parent_mnt_id = 0;
+	int status = 1;
+#endif
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+	if (susfs_sus_mount(mnt, &p->root))
+		return 0;
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+	if (!uid_matches_proc_need_to_reorder_mnt_id())
+		goto orig_flow;
+	status = susfs_get_fake_mnt_id(r->mnt_id, &out_mnt_id, &out_parent_mnt_id);
+	if (status)
+		goto orig_flow;
+	seq_printf(m, "%i %i %u:%u ", out_mnt_id, out_parent_mnt_id,
+				MAJOR(sb->s_dev), MINOR(sb->s_dev));
+	goto bypass_orig_flow;
+orig_flow:
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 	seq_printf(m, "%i %i %u:%u ", r->mnt_id, r->mnt_parent->mnt_id,
 		   MAJOR(sb->s_dev), MINOR(sb->s_dev));
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+bypass_orig_flow:
+#endif
+
 	if (sb->s_op->show_path) {
 		err = sb->s_op->show_path(m, mnt->mnt_root);
 		if (err)
@@ -202,6 +234,11 @@ static int show_vfsstat(struct seq_file *m, struct vfsmount *mnt)
 	struct super_block *sb = mnt_path.dentry->d_sb;
 	int err;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+	if (susfs_sus_mount(mnt, &p->root))
+		return 0;
+#endif
+
 	/* device */
 	if (sb->s_op->show_devname) {
 		seq_puts(m, "device ");
@@ -285,6 +322,12 @@ static int mounts_open_common(struct inode *inode, struct file *file,
 	p->show = show;
 	p->cached_event = ~0ULL;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+	if (uid_matches_proc_need_to_reorder_mnt_id()) {
+		susfs_add_mnt_id_recorder(p->ns);
+	}
+#endif
+
 	return 0;
 
  err_put_path:
@@ -299,6 +342,13 @@ static int mounts_release(struct inode *inode, struct file *file)
 {
 	struct seq_file *m = file->private_data;
 	struct proc_mounts *p = m->private;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+	if (uid_matches_proc_need_to_reorder_mnt_id()) {
+		susfs_remove_mnt_id_recorder();
+	}
+#endif
+
 	path_put(&p->root);
 	put_mnt_ns(p->ns);
 	return seq_release_private(inode, file);
diff --git a/fs/readdir.c b/fs/readdir.c
index 07a3b5baa4047..a3d709fa53125 100644
--- a/fs/readdir.c
+++ b/fs/readdir.c
@@ -22,6 +22,10 @@
 #include <linux/compat.h>
 #include <linux/uaccess.h>
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 #include <asm/unaligned.h>
 
 /*
@@ -328,6 +332,11 @@ static int filldir64(struct dir_context *ctx, const char *name, int namlen,
 	prev_reclen = buf->prev_reclen;
 	if (prev_reclen && signal_pending(current))
 		return -EINTR;
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+		if (susfs_sus_ino_for_filldir64(ino)) {
+			return 0;
+		}
+#endif
 	dirent = buf->current_dir;
 	prev = (void __user *)dirent - prev_reclen;
 	if (!user_access_begin(prev, reclen + prev_reclen))
diff --git a/fs/stat.c b/fs/stat.c
index e3a616b8743fd..70d9ff1a300af 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -21,6 +21,10 @@
 #include <linux/uaccess.h>
 #include <asm/unistd.h>
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 /**
  * generic_fillattr - Fill in the basic attributes from the inode struct
  * @inode: Inode to use as the source
@@ -112,6 +116,12 @@ int vfs_getattr(const struct path *path, struct kstat *stat,
 {
 	int retval;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (susfs_sus_path_by_path(path, &retval, SYSCALL_FAMILY_ALL_ENOENT)) {
+		return retval;
+	}
+#endif
+
 	retval = security_inode_getattr(path);
 	if (retval)
 		return retval;
@@ -338,6 +348,9 @@ static int cp_new_stat(struct kstat *stat, struct stat __user *statbuf)
 #endif
 	tmp.st_blocks = stat->blocks;
 	tmp.st_blksize = stat->blksize;
+#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
+	susfs_sus_kstat(tmp.st_ino, &tmp);
+#endif
 	return copy_to_user(statbuf,&tmp,sizeof(tmp)) ? -EFAULT : 0;
 }
 
diff --git a/fs/susfs.c b/fs/susfs.c
new file mode 100644
index 0000000000000..3d1822fed1024
--- /dev/null
+++ b/fs/susfs.c
@@ -0,0 +1,1427 @@
+#include <linux/version.h>
+#include <linux/cred.h>
+#include <linux/fs.h>
+#include <linux/path.h>
+#include <linux/slab.h>
+#include <linux/seq_file.h>
+#include <linux/printk.h>
+#include <linux/namei.h>
+#include <linux/list.h>
+#include <linux/init_task.h>
+#include <linux/spinlock.h>
+#include <linux/stat.h>
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#include <linux/fdtable.h>
+#include <linux/mnt_namespace.h>
+#include "internal.h"
+#include "mount.h"
+#include <linux/susfs.h>
+
+LIST_HEAD(LH_SUS_PATH);
+LIST_HEAD(LH_SUS_KSTAT_SPOOFER);
+LIST_HEAD(LH_SUS_MOUNT);
+LIST_HEAD(LH_SUS_MAPS_SPOOFER);
+LIST_HEAD(LH_SUS_PROC_FD_LINK);
+LIST_HEAD(LH_SUS_MEMFD);
+LIST_HEAD(LH_TRY_UMOUNT_PATH);
+LIST_HEAD(LH_MOUNT_ID_RECORDER);
+
+struct st_susfs_uname my_uname;
+
+spinlock_t susfs_spin_lock;
+spinlock_t susfs_mnt_id_recorder_spin_lock;
+
+bool is_log_enable = true;
+#ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
+#define SUSFS_LOGI(fmt, ...) if (is_log_enable) pr_info("susfs:[%u][%u][%s] " fmt, current_uid().val, current->pid, __func__, ##__VA_ARGS__)
+#define SUSFS_LOGE(fmt, ...) if (is_log_enable) pr_err("susfs:[%u][%u][%s]" fmt, current_uid().val, current->pid, __func__, ##__VA_ARGS__)
+#else
+#define SUSFS_LOGI(fmt, ...) 
+#define SUSFS_LOGE(fmt, ...) 
+#endif
+
+int susfs_add_sus_path(struct st_susfs_sus_path* __user user_info) {
+	struct st_susfs_sus_path_list *cursor, *temp;
+	struct st_susfs_sus_path_list *new_list = NULL;
+	struct st_susfs_sus_path info;
+
+	if (copy_from_user(&info, user_info, sizeof(struct st_susfs_sus_path))) {
+		SUSFS_LOGE("failed copying from userspace\n");
+		return 1;
+	}
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_PATH, list) {
+		if (unlikely(!strcmp(info.target_pathname, cursor->info.target_pathname))) {
+			SUSFS_LOGE("target_pathname: '%s' is already created in LH_SUS_PATH\n", info.target_pathname);
+			return 1;
+		}
+	}
+
+	new_list = kmalloc(sizeof(struct st_susfs_sus_path_list), GFP_KERNEL);
+	if (!new_list) {
+		SUSFS_LOGE("no enough memory\n");
+		return 1;
+	}
+
+	memcpy(&new_list->info, &info, sizeof(struct st_susfs_sus_path));
+
+	INIT_LIST_HEAD(&new_list->list);
+	spin_lock(&susfs_spin_lock);
+	list_add_tail(&new_list->list, &LH_SUS_PATH);
+	spin_unlock(&susfs_spin_lock);
+	SUSFS_LOGI("target_pathname: '%s' is successfully added to LH_SUS_PATH\n", info.target_pathname);
+	return 0;
+}
+
+int susfs_add_sus_mount(struct st_susfs_sus_mount* __user user_info) {
+	struct st_susfs_sus_mount_list *cursor, *temp;
+	struct st_susfs_sus_mount_list *new_list = NULL;
+	struct st_susfs_sus_mount info;
+	int list_count = 0;
+
+	if (copy_from_user(&info, user_info, sizeof(struct st_susfs_sus_mount))) {
+		SUSFS_LOGE("failed copying from userspace\n");
+		return 1;
+	}
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_MOUNT, list) {
+		if (unlikely(!strcmp(cursor->info.target_pathname, info.target_pathname))) {
+			SUSFS_LOGE("target_pathname: '%s' is already created in LH_SUS_MOUNT\n", cursor->info.target_pathname);
+			return 1;
+		}
+		list_count++;
+	}
+
+	if (list_count == SUSFS_MAX_SUS_MNTS) {
+		SUSFS_LOGE("LH_SUS_MOUNT has reached the list limit of %d\n", SUSFS_MAX_SUS_MNTS);
+		return 1;
+	}
+
+	new_list = kmalloc(sizeof(struct st_susfs_sus_mount_list), GFP_KERNEL);
+	if (!new_list) {
+		SUSFS_LOGE("no enough memory\n");
+		return 1;
+	}
+
+	memcpy(&new_list->info, &info, sizeof(struct st_susfs_sus_mount));
+
+	INIT_LIST_HEAD(&new_list->list);
+	spin_lock(&susfs_spin_lock);
+	list_add_tail(&new_list->list, &LH_SUS_MOUNT);
+	spin_unlock(&susfs_spin_lock);
+	SUSFS_LOGI("target_pathname: '%s', is successfully added to LH_SUS_MOUNT\n", new_list->info.target_pathname);
+	return 0;
+}
+
+int susfs_add_sus_kstat(struct st_susfs_sus_kstat* __user user_info) {
+	struct st_susfs_sus_kstat_list *cursor, *temp;
+	struct st_susfs_sus_kstat_list *new_list = NULL;
+	struct st_susfs_sus_kstat info;
+
+	if (copy_from_user(&info, user_info, sizeof(struct st_susfs_sus_kstat))) {
+		SUSFS_LOGE("failed copying from userspace\n");
+		return 1;
+	}
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_KSTAT_SPOOFER, list) {
+		if (cursor->info.target_ino == info.target_ino) {
+			if (info.target_pathname[0] != '\0') {
+				SUSFS_LOGE("target_pathname: '%s' is already created in LH_SUS_KSTAT_SPOOFER\n", info.target_pathname);
+			} else {
+				SUSFS_LOGE("target_ino: '%lu' is already created in LH_SUS_KSTAT_SPOOFER\n", info.target_ino);
+			}
+			return 1;
+		}
+	}
+
+	new_list = kmalloc(sizeof(struct st_susfs_sus_kstat_list), GFP_KERNEL);
+	if (!new_list) {
+		SUSFS_LOGE("no enough memory\n");
+		return 1;
+	}
+
+	memcpy(&new_list->info, &info, sizeof(struct st_susfs_sus_kstat));
+	/* Seems the dev number issue is finally solved, the userspace stat we see is already a encoded dev
+	 * which is set by new_encode_dev() / huge_encode_dev() function for 64bit system and 
+	 * old_encode_dev() for 32bit only system, that's why we need to decode it in kernel as well,
+	 * and different kernel may have different function to encode the dev number, be cautious!
+	 * Also check your encode_dev() macro in fs/stat.c to determine which one to use 
+	 */
+#if defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64)
+#ifdef CONFIG_MIPS
+	new_list->info.spoofed_dev = new_decode_dev(new_list->info.spoofed_dev);
+#else
+	new_list->info.spoofed_dev = huge_decode_dev(new_list->info.spoofed_dev);
+#endif /* CONFIG_MIPS */
+#else
+	new_list->info.spoofed_dev = old_decode_dev(new_list->info.spoofed_dev);
+#endif /* defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64) */
+	INIT_LIST_HEAD(&new_list->list);
+	spin_lock(&susfs_spin_lock);
+	list_add_tail(&new_list->list, &LH_SUS_KSTAT_SPOOFER);
+	spin_unlock(&susfs_spin_lock);
+	SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', spoofed_pathname: '%s', spoofed_ino: '%lu', spoofed_dev: '%lu', spoofed_nlink: '%u', spoofed_atime_tv_sec: '%ld', spoofed_mtime_tv_sec: '%ld', spoofed_ctime_tv_sec: '%ld', spoofed_atime_tv_nsec: '%ld', spoofed_mtime_tv_nsec: '%ld', spoofed_ctime_tv_nsec: '%ld', is successfully added to LH_SUS_KSTAT_SPOOFER\n",
+		new_list->info.target_ino , new_list->info.target_pathname, new_list->info.spoofed_pathname,
+		new_list->info.spoofed_ino, new_list->info.spoofed_dev, new_list->info.spoofed_nlink,
+		new_list->info.spoofed_atime_tv_sec, new_list->info.spoofed_mtime_tv_sec, new_list->info.spoofed_ctime_tv_sec,
+		new_list->info.spoofed_atime_tv_nsec, new_list->info.spoofed_mtime_tv_nsec, new_list->info.spoofed_ctime_tv_nsec);
+	return 0;
+}
+
+int susfs_update_sus_kstat(struct st_susfs_sus_kstat* __user user_info) {
+	struct st_susfs_sus_kstat_list *cursor, *temp;
+	struct st_susfs_sus_kstat info;
+
+	if (copy_from_user(&info, user_info, sizeof(struct st_susfs_sus_kstat))) {
+		SUSFS_LOGE("failed copying from userspace\n");
+		return 1;
+	}
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_KSTAT_SPOOFER, list) {
+		if (unlikely(!strcmp(info.target_pathname, cursor->info.target_pathname))) {
+			SUSFS_LOGI("updating target_ino from '%lu' to '%lu' for pathname: '%s' in LH_SUS_KSTAT_SPOOFER\n", cursor->info.target_ino, info.target_ino, info.target_pathname);
+			cursor->info.target_ino = info.target_ino;
+			return 0;
+		}
+	}
+
+	SUSFS_LOGE("target_pathname: '%s' is not found in LH_SUS_KSTAT_SPOOFER\n", info.target_pathname);
+	return 1;
+}
+
+int susfs_add_sus_maps(struct st_susfs_sus_maps* __user user_info) {
+	struct st_susfs_sus_maps_list *cursor, *temp;
+	struct st_susfs_sus_maps_list *new_list = NULL;
+	struct st_susfs_sus_maps info;
+	int list_count = 0;
+
+	if (copy_from_user(&info, user_info, sizeof(struct st_susfs_sus_maps))) {
+		SUSFS_LOGE("failed copying from userspace\n");
+		return 1;
+	}
+
+#if defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64)
+#ifdef CONFIG_MIPS
+	info.target_dev = new_decode_dev(info.target_dev);
+#else
+	info.target_dev = huge_decode_dev(info.target_dev);
+#endif /* CONFIG_MIPS */
+#else
+	info.target_dev = old_decode_dev(info.target_dev);
+#endif /* defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64) */
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_MAPS_SPOOFER, list) {
+		if (cursor->info.is_statically == info.is_statically && !info.is_statically) {
+			if (cursor->info.target_ino == info.target_ino) {
+				SUSFS_LOGE("is_statically: '%d', target_ino: '%lu', is already created in LH_SUS_MAPS_SPOOFER\n",
+				info.is_statically, info.target_ino);
+				return 1;
+			}
+		} else if (cursor->info.is_statically == info.is_statically && info.is_statically) {
+			if (cursor->info.compare_mode == info.compare_mode && info.compare_mode == 1) {
+				if (cursor->info.target_ino == info.target_ino) {
+					SUSFS_LOGE("is_statically: '%d', compare_mode: '%d', target_ino: '%lu', is already created in LH_SUS_MAPS_SPOOFER\n",
+					info.is_statically, info.compare_mode, info.target_ino);
+					return 1;
+				}
+			} else if (cursor->info.compare_mode == info.compare_mode && info.compare_mode == 2) {
+				if (cursor->info.target_ino == info.target_ino &&
+					cursor->info.is_isolated_entry == info.is_isolated_entry &&
+					cursor->info.target_addr_size == info.target_addr_size &&
+				    cursor->info.target_pgoff == info.target_pgoff &&
+					cursor->info.target_prot == info.target_prot) {
+					SUSFS_LOGE("is_statically: '%d', compare_mode: '%d', target_ino: '%lu', is_isolated_entry: '%d', target_pgoff: '0x%x', target_prot: '0x%x', is already created in LH_SUS_MAPS_SPOOFER\n",
+					info.is_statically, info.compare_mode, info.target_ino,
+					info.is_isolated_entry, info.target_pgoff, info.target_prot);
+					return 1;
+				}
+			} else if (cursor->info.compare_mode == info.compare_mode && info.compare_mode == 3) {
+				if (info.target_ino == 0 &&
+					cursor->info.prev_target_ino == info.prev_target_ino &&
+				    cursor->info.next_target_ino == info.next_target_ino) {
+					SUSFS_LOGE("is_statically: '%d', compare_mode: '%d', target_ino: '%lu', prev_target_ino: '%lu', next_target_ino: '%lu', is already created in LH_SUS_MAPS_SPOOFER\n",
+					info.is_statically, info.compare_mode, info.target_ino,
+					info.prev_target_ino, info.next_target_ino);
+					return 1;
+				}
+			} else if (cursor->info.compare_mode == info.compare_mode && info.compare_mode == 4) {
+				if (cursor->info.is_file == info.is_file &&
+					cursor->info.target_dev == info.target_dev &&
+				    cursor->info.target_pgoff == info.target_pgoff &&
+				    cursor->info.target_prot == info.target_prot &&
+				    cursor->info.target_addr_size == info.target_addr_size) {
+					SUSFS_LOGE("is_statically: '%d', compare_mode: '%d', is_file: '%d', target_dev: '0x%x', target_pgoff: '0x%x', target_prot: '0x%x', target_addr_size: '0x%x', is already created in LH_SUS_MAPS_SPOOFER\n",
+					info.is_statically, info.compare_mode, info.is_file,
+					info.target_dev, info.target_pgoff, info.target_prot,
+					info.target_addr_size);
+					return 1;
+				}
+			}
+		}
+		list_count++;
+	}
+
+	if (list_count == SUSFS_MAX_SUS_MAPS) {
+		SUSFS_LOGE("LH_SUS_MOUNT has reached the list limit of %d\n", SUSFS_MAX_SUS_MAPS);
+		return 1;
+	}
+
+	new_list = kmalloc(sizeof(struct st_susfs_sus_maps_list), GFP_KERNEL);
+	if (!new_list) {
+		SUSFS_LOGE("no enough memory\n");
+		return 1;
+	}
+
+	memcpy(&new_list->info, &info, sizeof(struct st_susfs_sus_maps));
+#if defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64)
+#ifdef CONFIG_MIPS
+	new_list->info.spoofed_dev = new_decode_dev(new_list->info.spoofed_dev);
+#else
+	new_list->info.spoofed_dev = huge_decode_dev(new_list->info.spoofed_dev);
+#endif /* CONFIG_MIPS */
+#else
+	new_list->info.spoofed_dev = old_decode_dev(new_list->info.spoofed_dev);
+#endif /* defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64) */
+	INIT_LIST_HEAD(&new_list->list);
+	spin_lock(&susfs_spin_lock);
+	list_add_tail(&new_list->list, &LH_SUS_MAPS_SPOOFER);
+	spin_unlock(&susfs_spin_lock);
+
+	SUSFS_LOGI("is_statically: '%d', compare_mode: '%d', is_isolated_entry: '%d', is_file: '%d', prev_target_ino: '%lu', next_target_ino: '%lu', target_ino: '%lu', target_dev: '0x%x', target_pgoff: '0x%x', target_prot: '0x%x', target_addr_size: '0x%x', spoofed_pathname: '%s', spoofed_ino: '%lu', spoofed_dev: '0x%x', spoofed_pgoff: '0x%x', spoofed_prot: '0x%x', is successfully added to LH_SUS_MAPS_SPOOFER\n",
+	new_list->info.is_statically, new_list->info.compare_mode, new_list->info.is_isolated_entry,
+	new_list->info.is_file, new_list->info.prev_target_ino, new_list->info.next_target_ino,
+	new_list->info.target_ino, new_list->info.target_dev, new_list->info.target_pgoff,
+	new_list->info.target_prot, new_list->info.target_addr_size, new_list->info.spoofed_pathname,
+	new_list->info.spoofed_ino, new_list->info.spoofed_dev, new_list->info.spoofed_pgoff,
+	new_list->info.spoofed_prot);
+
+	return 0;
+}
+
+int susfs_update_sus_maps(struct st_susfs_sus_maps* __user user_info) {
+	struct st_susfs_sus_maps_list *cursor, *temp;
+	struct st_susfs_sus_maps info;
+
+	if (copy_from_user(&info, user_info, sizeof(struct st_susfs_sus_maps))) {
+		SUSFS_LOGE("failed copying from userspace\n");
+		return 1;
+	}
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_MAPS_SPOOFER, list) {
+		if (cursor->info.is_statically == info.is_statically && !info.is_statically) {
+			if (unlikely(!strcmp(info.target_pathname, cursor->info.target_pathname))) {
+				SUSFS_LOGI("updating target_ino from '%lu' to '%lu' for pathname: '%s' in LH_SUS_MAPS_SPOOFER\n", cursor->info.target_ino, info.target_ino, info.target_pathname);
+				cursor->info.target_ino = info.target_ino;
+				return 0;
+			}
+		}
+	}
+
+	SUSFS_LOGE("target_pathname: '%s' is not found in LH_SUS_MAPS_SPOOFER\n", info.target_pathname);
+	return 1;
+}
+
+int susfs_add_sus_proc_fd_link(struct st_susfs_sus_proc_fd_link* __user user_info) {
+	struct st_susfs_sus_proc_fd_link_list *cursor, *temp;
+	struct st_susfs_sus_proc_fd_link_list *new_list = NULL;
+	struct st_susfs_sus_proc_fd_link info;
+
+	if (copy_from_user(&info, user_info, sizeof(struct st_susfs_sus_proc_fd_link))) {
+		SUSFS_LOGE("failed copying from userspace\n");
+		return 1;
+	}
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_PROC_FD_LINK, list) {
+		if (unlikely(!strcmp(info.target_link_name, cursor->info.target_link_name))) {
+			SUSFS_LOGE("target_link_name: '%s' is already created in LH_SUS_PROC_FD_LINK\n", info.target_link_name);
+			return 1;
+		}
+	}
+
+	new_list = kmalloc(sizeof(struct st_susfs_sus_proc_fd_link_list), GFP_KERNEL);
+	if (!new_list) {
+		SUSFS_LOGE("no enough memory\n");
+		return 1;
+	}
+
+	memcpy(&new_list->info, &info, sizeof(struct st_susfs_sus_proc_fd_link));
+
+	INIT_LIST_HEAD(&new_list->list);
+	spin_lock(&susfs_spin_lock);
+	list_add_tail(&new_list->list, &LH_SUS_PROC_FD_LINK);
+	spin_unlock(&susfs_spin_lock);
+	SUSFS_LOGI("target_link_name: '%s', spoofed_link_name: '%s', is successfully added to LH_SUS_PROC_FD_LINK\n",
+				new_list->info.target_link_name, new_list->info.spoofed_link_name);
+	return 0;
+}
+
+int susfs_add_sus_memfd(struct st_susfs_sus_memfd* __user user_info) {
+	struct st_susfs_sus_memfd_list *cursor, *temp;
+	struct st_susfs_sus_memfd_list *new_list = NULL;
+	struct st_susfs_sus_memfd info;
+
+	if (copy_from_user(&info, user_info, sizeof(struct st_susfs_sus_memfd))) {
+		SUSFS_LOGE("failed copying from userspace\n");
+		return 1;
+	}
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_MEMFD, list) {
+		if (unlikely(!strcmp(info.target_pathname, cursor->info.target_pathname))) {
+			SUSFS_LOGE("target_pathname: '%s' is already created in LH_SUS_MEMFD\n", info.target_pathname);
+			return 1;
+		}
+	}
+
+	new_list = kmalloc(sizeof(struct st_susfs_sus_memfd_list), GFP_KERNEL);
+	if (!new_list) {
+		SUSFS_LOGE("no enough memory\n");
+		return 1;
+	}
+
+	memcpy(&new_list->info, &info, sizeof(struct st_susfs_sus_memfd));
+
+	INIT_LIST_HEAD(&new_list->list);
+	spin_lock(&susfs_spin_lock);
+	list_add_tail(&new_list->list, &LH_SUS_MEMFD);
+	spin_unlock(&susfs_spin_lock);
+	SUSFS_LOGI("target_pathname: '%s', is successfully added to LH_SUS_MEMFD\n",
+				new_list->info.target_pathname);
+	return 0;
+}
+
+int susfs_add_try_umount(struct st_susfs_try_umount* __user user_info) {
+	struct st_susfs_try_umount_list *cursor, *temp;
+	struct st_susfs_try_umount_list *new_list = NULL;
+	struct st_susfs_try_umount info;
+
+	if (copy_from_user(&info, user_info, sizeof(struct st_susfs_try_umount))) {
+		SUSFS_LOGE("failed copying from userspace\n");
+		return 1;
+	}
+
+	list_for_each_entry_safe(cursor, temp, &LH_TRY_UMOUNT_PATH, list) {
+		if (unlikely(!strcmp(info.target_pathname, cursor->info.target_pathname))) {
+			SUSFS_LOGE("target_pathname: '%s' is already created in LH_TRY_UMOUNT_PATH\n", info.target_pathname);
+			return 1;
+		}
+	}
+
+	new_list = kmalloc(sizeof(struct st_susfs_try_umount_list), GFP_KERNEL);
+	if (!new_list) {
+		SUSFS_LOGE("no enough memory\n");
+		return 1;
+	}
+
+	memcpy(&new_list->info, &info, sizeof(struct st_susfs_try_umount));
+
+	INIT_LIST_HEAD(&new_list->list);
+	spin_lock(&susfs_spin_lock);
+	list_add_tail(&new_list->list, &LH_TRY_UMOUNT_PATH);
+	spin_unlock(&susfs_spin_lock);
+	SUSFS_LOGI("target_pathname: '%s', mnt_mode: %d, is successfully added to LH_TRY_UMOUNT_PATH\n", new_list->info.target_pathname, new_list->info.mnt_mode);
+	return 0;
+}
+
+int susfs_set_uname(struct st_susfs_uname* __user user_info) {
+	struct st_susfs_uname info;
+
+	if (copy_from_user(&info, user_info, sizeof(struct st_susfs_uname))) {
+		SUSFS_LOGE("failed copying from userspace.\n");
+		return 1;
+	}
+
+	spin_lock(&susfs_spin_lock);
+	strncpy(my_uname.sysname, info.sysname, __NEW_UTS_LEN);
+	strncpy(my_uname.nodename, info.nodename, __NEW_UTS_LEN);
+	strncpy(my_uname.release, info.release, __NEW_UTS_LEN);
+	strncpy(my_uname.version, info.version, __NEW_UTS_LEN);
+	strncpy(my_uname.machine, info.machine, __NEW_UTS_LEN);
+	SUSFS_LOGI("setting sysname: '%s', nodename: '%s', release: '%s', version: '%s', machine: '%s'\n",
+				my_uname.sysname, my_uname.nodename, my_uname.release, my_uname.version, my_uname.machine);
+	spin_unlock(&susfs_spin_lock);
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,19,0)
+int susfs_sus_path_by_path(struct path* file, int* errno_to_be_changed, int syscall_family)
+#else
+int susfs_sus_path_by_path(const struct path* file, int* errno_to_be_changed, int syscall_family)
+#endif
+{
+	int res = 0;
+	int status = 0;
+	char* path = NULL;
+	char* ptr = NULL;
+	char* end = NULL;
+	struct st_susfs_sus_path_list *cursor, *temp;
+
+	if (!uid_matches_suspicious_path() || file == NULL) {
+		return status;
+	}
+
+	path = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (path == NULL) {
+		SUSFS_LOGE("no enough memory\n");
+		return status;
+	}
+	ptr = d_path(file, path, PAGE_SIZE);
+	if (IS_ERR(ptr)) {
+		SUSFS_LOGE("d_path() failed\n");
+		goto out_free_path;
+	}
+	end = mangle_path(path, ptr, " \t\n\\");
+	if (!end) {
+		goto out_free_path;
+	}
+	res = end - path;
+	path[(size_t) res] = '\0';
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_PATH, list) {
+		if (unlikely(!strcmp(cursor->info.target_pathname, path))) {
+			SUSFS_LOGI("hiding target_pathname: '%s', target_ino: '%lu'\n", cursor->info.target_pathname, cursor->info.target_ino);
+			if (errno_to_be_changed != NULL) {
+				susfs_change_error_no_by_pathname(path, errno_to_be_changed, syscall_family);
+			}
+			status = 1;
+			goto out_free_path;
+		}
+	}
+
+out_free_path:
+	kfree(path);
+	return status;
+}
+
+int susfs_sus_path_by_filename(struct filename* name, int* errno_to_be_changed, int syscall_family) {
+	int status = 0;
+	int ret = 0;
+	struct path path;
+
+	if (IS_ERR(name)) {
+		return status;
+	}
+
+	if (!uid_matches_suspicious_path() || name == NULL) {
+		return status;
+	}
+
+	ret = kern_path(name->name, LOOKUP_FOLLOW, &path);
+
+	if (!ret) {
+		status = susfs_sus_path_by_path(&path, errno_to_be_changed, syscall_family);
+		path_put(&path);
+	}
+
+	return status;
+}
+
+int susfs_sus_ino_for_filldir64(unsigned long ino) {
+	struct st_susfs_sus_path_list *cursor, *temp;
+
+	if (!uid_matches_suspicious_path())
+		return 0;
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_PATH, list) {
+		if (cursor->info.target_ino == ino) {
+			SUSFS_LOGI("hiding target_pathname: '%s', target_ino: '%lu'\n", cursor->info.target_pathname, cursor->info.target_ino);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+int susfs_sus_mount(struct vfsmount* mnt, struct path* root) {
+	struct st_susfs_sus_mount_list *cursor, *temp;
+	char* path = NULL;
+	char* ptr = NULL;
+	char* end = NULL;
+	int res = 0;
+	int status = 0;
+	struct path mnt_path = {
+		.dentry = mnt->mnt_root,
+		.mnt = mnt
+	};
+
+	path = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (path == NULL) {
+		SUSFS_LOGE("no enough memory\n");
+		return 0;
+	}
+	ptr = __d_path(&mnt_path, root, path, PAGE_SIZE);
+	if (IS_ERR(ptr)) {
+		SUSFS_LOGE("__d_path() failed\n");
+		goto out_free_path;
+	}
+	end = mangle_path(path, ptr, " \t\n\\");
+	if (!end) {
+		goto out_free_path;
+	}
+	res = end - path;
+	path[(size_t) res] = '\0';
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_MOUNT, list) {
+		if (unlikely(!strcmp(path, cursor->info.target_pathname))) {
+			SUSFS_LOGI("hide target_pathname '%s' from mounts\n",
+						cursor->info.target_pathname);
+			status = 1;
+			goto out_free_path;
+		}
+	}
+out_free_path:
+	kfree(path);
+	return status;
+}
+
+/*  This function records the original mnt_id and parent_mnt_id of all mounts of
+ *  current process and save to a list of corresponding spoofed mnt_id and parent_mnt_id
+ *  once process with uid >= 10000 opens /proc/self/mountinfo
+ */
+void susfs_add_mnt_id_recorder(struct mnt_namespace *ns) {
+	struct st_susfs_mnt_id_recorder_list *new_recorder_list = NULL;
+	struct st_susfs_mnt_id_recorder_list *recorder_cursor, *recorder_temp;
+	struct st_susfs_sus_mount_list *sus_mount_cursor, *sus_mount_temp;
+	struct mount *mnt_cursor, *mnt_temp; 
+	struct path mnt_path;
+	char *path = NULL;
+	char *p_path = NULL;
+	char *end = NULL;
+	int res = 0;
+	int cur_pid = current->pid;
+	int i = 0, count = 0;
+
+	if (!ns)
+		return;
+
+	// if there exists the same pid already, increase the reference
+	list_for_each_entry_safe(recorder_cursor, recorder_temp, &LH_MOUNT_ID_RECORDER, list) {
+		if (recorder_cursor->pid == cur_pid) {
+			recorder_cursor->opened_count++;
+			SUSFS_LOGI("mountinfo opened by the same pid: '%d', recorder_cursor->opened_count: '%d'\n",
+						cur_pid, recorder_cursor->opened_count);
+			return;
+		}
+	}
+
+	new_recorder_list = kzalloc(sizeof(struct st_susfs_mnt_id_recorder_list), GFP_KERNEL);
+	if (!new_recorder_list) {
+		SUSFS_LOGE("no enough memory\n");
+		return;
+	}
+	new_recorder_list->info.count = 0;
+
+	path = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!path) {
+		SUSFS_LOGE("no enough memory\n");
+		goto out_free_new_recorder_list;
+	}
+
+	list_for_each_entry_safe(mnt_cursor, mnt_temp, &ns->list, mnt_list) {
+		// Avoid overflow
+		if (count == SUSFS_MAX_SUS_MNTS) {
+			SUSFS_LOGE("LH_MOUNT_ID_RECORDER has reached the list limit of %d\n", SUSFS_MAX_SUS_MNTS);
+			goto out_free_path;
+		}
+		// if this is the first mount entry
+		if (count == 0) {
+			new_recorder_list->info.target_mnt_id[count] = mnt_cursor->mnt_id;
+			new_recorder_list->info.spoofed_mnt_id[count] = mnt_cursor->mnt_id;
+			new_recorder_list->info.spoofed_parent_mnt_id[count] = mnt_cursor->mnt_parent->mnt_id;
+			new_recorder_list->info.count = ++count;
+			continue;
+		}
+
+		mntget(&mnt_cursor->mnt);
+		dget(mnt_cursor->mnt.mnt_root);
+		mnt_path.mnt = &mnt_cursor->mnt;
+		mnt_path.dentry = mnt_cursor->mnt.mnt_root;
+
+		p_path = d_path(&mnt_path, path, PAGE_SIZE);
+		if (IS_ERR(p_path)) {
+			SUSFS_LOGE("d_path() failed\n");
+			goto out_continue;
+		}
+		end = mangle_path(path, p_path, " \t\n\\");
+		if (!end) {
+			goto out_continue;
+		}
+		res = end - path;
+		path[(size_t) res] = '\0';
+
+		// check if the mount is suspicious
+		list_for_each_entry_safe(sus_mount_cursor, sus_mount_temp, &LH_SUS_MOUNT, list) {
+			// skip adding this mount to recorder list if it is suspicious
+			if (unlikely(!strcmp(path, sus_mount_cursor->info.target_pathname))) {
+				SUSFS_LOGI("skip adding target_mnt_id: '%d', target_pathname: '%s' to LH_MOUNT_ID_RECORDER\n",
+							mnt_cursor->mnt_id, sus_mount_cursor->info.target_pathname);
+				goto out_continue;
+			}
+		}
+		// if the mount entry is NOT suspicioius
+		new_recorder_list->info.target_mnt_id[count] = mnt_cursor->mnt_id;
+		new_recorder_list->info.spoofed_mnt_id[count] = new_recorder_list->info.spoofed_mnt_id[0] + count;
+		for (i = 0; i < count; i++) {
+			if (mnt_cursor->mnt_parent->mnt_id == new_recorder_list->info.target_mnt_id[i]) {
+				new_recorder_list->info.spoofed_parent_mnt_id[count] = new_recorder_list->info.spoofed_mnt_id[i];
+				break;
+			}
+		}
+		// if no match from above, use the original parent mnt_id
+		if (new_recorder_list->info.spoofed_parent_mnt_id[count] == 0) {
+			new_recorder_list->info.spoofed_parent_mnt_id[count] == mnt_cursor->mnt_parent->mnt_id;
+		}
+		new_recorder_list->info.count = ++count;
+out_continue:
+		dput(mnt_cursor->mnt.mnt_root);
+		mntput(&mnt_cursor->mnt);
+	}
+
+	new_recorder_list->pid = cur_pid;
+	new_recorder_list->opened_count = 1;
+	kfree(path);
+
+	/*
+	for (i = 0; i<new_recorder_list->info.count; i++) {
+		SUSFS_LOGI("target_mnt_id: %d, spoofed_mnt_id: %d, spoofed_parent_mnt_id: %d\n",
+				new_recorder_list->info.target_mnt_id[i],
+				new_recorder_list->info.spoofed_mnt_id[i],
+				new_recorder_list->info.spoofed_parent_mnt_id[i]);
+	}
+	*/
+
+	INIT_LIST_HEAD(&new_recorder_list->list);
+	spin_lock(&susfs_mnt_id_recorder_spin_lock);
+	list_add_tail(&new_recorder_list->list, &LH_MOUNT_ID_RECORDER);
+	spin_unlock(&susfs_mnt_id_recorder_spin_lock);
+	SUSFS_LOGI("recording pid '%u' to LH_MOUNT_ID_RECORDER\n", new_recorder_list->pid);
+	return;
+out_free_path:
+	kfree(path);
+out_free_new_recorder_list:
+	kfree(new_recorder_list);
+}
+
+int susfs_get_fake_mnt_id(int mnt_id, int *out_mnt_id, int *out_parent_mnt_id) {
+	struct st_susfs_mnt_id_recorder_list *cursor, *temp;
+	int cur_pid = current->pid;
+	int i;
+
+	list_for_each_entry_safe(cursor, temp, &LH_MOUNT_ID_RECORDER, list) {
+		if (cursor->pid == cur_pid) {
+			for (i = 0; i < cursor->info.count; i++) {
+				if (cursor->info.target_mnt_id[i] == mnt_id) {
+					*out_mnt_id = cursor->info.spoofed_mnt_id[i];
+					*out_parent_mnt_id = cursor->info.spoofed_parent_mnt_id[i];
+					return 0;
+				}
+			}
+			return 1;
+		}
+	}
+	return 1;
+}
+
+void susfs_remove_mnt_id_recorder(void) {
+	struct st_susfs_mnt_id_recorder_list *cursor, *temp;
+	int cur_pid = current->pid;
+
+	spin_lock(&susfs_mnt_id_recorder_spin_lock);
+	list_for_each_entry_safe(cursor, temp, &LH_MOUNT_ID_RECORDER, list) {
+		if (cursor->pid == cur_pid) {
+			cursor->opened_count--;
+			if (cursor->opened_count != 0)
+				goto out_spin_unlock;
+			list_del(&cursor->list);
+			kfree(cursor);
+			SUSFS_LOGI("removing pid '%u' from LH_MOUNT_ID_RECORDER\n", cur_pid);
+			goto out_spin_unlock;
+		}
+	}
+out_spin_unlock:
+	spin_unlock(&susfs_mnt_id_recorder_spin_lock);
+}
+
+void susfs_sus_kstat(unsigned long ino, struct stat* out_stat) {
+	struct st_susfs_sus_kstat_list *cursor, *temp;
+
+	if (!uid_matches_suspicious_kstat())
+		return;
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_KSTAT_SPOOFER, list) {
+		if (cursor->info.target_ino == ino) {
+			SUSFS_LOGI("spoofing kstat for pathname '%s' for UID %i\n", cursor->info.target_pathname, current_uid().val);
+			out_stat->st_ino = cursor->info.spoofed_ino;
+#if defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64)
+#ifdef CONFIG_MIPS
+			out_stat->st_dev = new_encode_dev(cursor->info.spoofed_dev);
+#else
+			out_stat->st_dev = huge_encode_dev(cursor->info.spoofed_dev);
+#endif /* CONFIG_MIPS */
+#else
+			out_stat->st_dev = old_encode_dev(cursor->info.spoofed_dev);
+#endif /* defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64) */
+			out_stat->st_nlink = cursor->info.spoofed_nlink;
+			out_stat->st_atime = cursor->info.spoofed_atime_tv_sec;
+			out_stat->st_mtime = cursor->info.spoofed_mtime_tv_sec;
+			out_stat->st_ctime = cursor->info.spoofed_ctime_tv_sec;
+#ifdef _STRUCT_TIMESPEC
+			out_stat->st_atime_nsec = cursor->info.spoofed_atime_tv_nsec;
+			out_stat->st_mtime_nsec = cursor->info.spoofed_mtime_tv_nsec;
+			out_stat->st_ctime_nsec = cursor->info.spoofed_ctime_tv_nsec;
+#endif
+			return;
+		}
+	}
+}
+
+/* for non statically, it only compare with target_ino, and spoof only the ino, dev to the matched entry
+ * for staticially, it compares depending on the mode user chooses
+ * compare mode:
+ *  1 -> target_ino is 'non-zero', all entries match with target_ino will be spoofed with user defined entry
+ *  2 -> target_ino is 'non-zero', all entries match with [target_ino,target_addr_size,target_prot,target_pgoff,is_isolated_entry] will be spoofed with user defined entry
+ *  3 -> target_ino is 'zero', which is not file, all entries match with [prev_target_ino,next_target_ino] will be spoofed with user defined entry
+ *  4 -> target_ino is 'zero' or 'non-zero', all entries match with [is_file,target_addr_size,target_prot,target_pgoff,target_dev] will be spoofed with user defined entry
+ */
+int susfs_sus_maps(unsigned long target_ino, unsigned long target_addr_size, unsigned long* orig_ino, dev_t* orig_dev, vm_flags_t* flags, unsigned long long* pgoff, struct vm_area_struct* vma, char* out_name) {
+	struct st_susfs_sus_maps_list *cursor, *temp;
+	struct inode *tmp_inode, *tmp_inode_prev, *tmp_inode_next;
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_MAPS_SPOOFER, list) {
+		// if it is NOT statically
+		if (!cursor->info.is_statically) {
+			if (target_ino != 0 && cursor->info.target_ino == target_ino) {
+				*orig_ino = cursor->info.spoofed_ino;
+				*orig_dev = cursor->info.spoofed_dev;
+				SUSFS_LOGI("spoofing maps -> is_statically: '%d', compare_mode: '%d', is_file: '%d', is_isolated_entry: '%d', prev_target_ino: '%lu', next_target_ino: '%lu', target_ino: '%lu', target_dev: '0x%x', target_pgoff: '0x%x', target_prot: '0x%x', target_addr_size: '0x%x', spoofed_pathname: '%s', spoofed_ino: '%lu', spoofed_dev: '0x%x', spoofed_pgoff: '0x%x', spoofed_prot: '0x%x'\n",
+				cursor->info.is_statically, cursor->info.compare_mode, cursor->info.is_file,
+				cursor->info.is_isolated_entry, cursor->info.prev_target_ino, cursor->info.next_target_ino,
+				cursor->info.target_ino, cursor->info.target_dev, cursor->info.target_pgoff,
+				cursor->info.target_prot, cursor->info.target_addr_size, cursor->info.spoofed_pathname,
+				cursor->info.spoofed_ino, cursor->info.spoofed_dev, cursor->info.spoofed_pgoff,
+				cursor->info.spoofed_prot);
+				return 1;
+			}
+		// if it is statically, then compare with compare_mode
+		} else if (cursor->info.compare_mode > 0) {
+			switch(cursor->info.compare_mode) {
+				case 1:
+					if (target_ino != 0 && cursor->info.target_ino == target_ino) {
+						goto do_spoof;
+					}
+					break;
+				case 2:
+					if (target_ino != 0 && cursor->info.target_ino == target_ino &&
+						((cursor->info.target_prot & VM_READ) == (*flags & VM_READ)) &&
+						((cursor->info.target_prot & VM_WRITE) == (*flags & VM_WRITE)) &&
+						((cursor->info.target_prot & VM_EXEC) == (*flags & VM_EXEC)) &&
+						((cursor->info.target_prot & VM_MAYSHARE) == (*flags & VM_MAYSHARE)) &&
+						  cursor->info.target_addr_size == target_addr_size &&
+						  cursor->info.target_pgoff == *pgoff) {
+						// if is NOT isolated_entry, check for vma->vm_next and vma->vm_prev to see if they have the same inode
+						if (!cursor->info.is_isolated_entry) {
+							if (vma && vma->vm_next) {
+								if (vma->vm_next->vm_file) {
+									tmp_inode = file_inode(vma->vm_next->vm_file);
+									if (tmp_inode->i_ino == cursor->info.target_ino)
+										goto do_spoof;
+								}
+							}
+							if (vma && vma->vm_prev) {
+								if (vma->vm_prev->vm_file) {
+									tmp_inode = file_inode(vma->vm_prev->vm_file);
+									if (tmp_inode->i_ino == cursor->info.target_ino)
+										goto do_spoof;
+								}
+							}
+							continue;
+						// if it is isolated_entry
+						} else {
+							if (vma && vma->vm_next) {
+								if (vma->vm_next->vm_file) {
+									tmp_inode = file_inode(vma->vm_next->vm_file);
+									if (tmp_inode->i_ino == cursor->info.target_ino) {
+										continue;
+									}
+								}
+							}
+							if (vma && vma->vm_prev) {
+								if (vma->vm_prev->vm_file) {
+									tmp_inode = file_inode(vma->vm_prev->vm_file);
+									if (tmp_inode->i_ino == cursor->info.target_ino) {
+										continue;
+									}
+								}
+							}
+							// both prev and next don't have the same indoe as current entry, we can spoof now
+							goto do_spoof;
+						}
+					}
+					break;
+				case 3:
+					// if current vma is a file, it is not our target
+					if (vma->vm_file) continue;
+					// compare next target ino only
+					if (cursor->info.prev_target_ino == 0 && cursor->info.next_target_ino > 0) {
+						if (vma->vm_next && vma->vm_next->vm_file) {
+							tmp_inode_next = file_inode(vma->vm_next->vm_file);
+							if (tmp_inode_next->i_ino == cursor->info.next_target_ino) {
+								goto do_spoof;
+							}
+						}
+					// compare prev target ino only
+					} else if (cursor->info.prev_target_ino > 0 && cursor->info.next_target_ino == 0) {
+						if (vma->vm_prev && vma->vm_prev->vm_file) {
+							tmp_inode_prev = file_inode(vma->vm_prev->vm_file);
+							if (tmp_inode_prev->i_ino == cursor->info.prev_target_ino) {
+								goto do_spoof;
+							}
+						}
+					// compare both prev ino and next ino
+					} else if (cursor->info.prev_target_ino > 0 && cursor->info.next_target_ino > 0) {
+						if (vma->vm_prev && vma->vm_prev->vm_file &&
+							vma->vm_next && vma->vm_next->vm_file) {
+							tmp_inode_prev = file_inode(vma->vm_prev->vm_file);
+							tmp_inode_next = file_inode(vma->vm_next->vm_file);
+							if (tmp_inode_prev->i_ino == cursor->info.prev_target_ino &&
+							    tmp_inode_next->i_ino == cursor->info.next_target_ino) {
+								goto do_spoof;
+							}
+						}
+					}
+					break;
+				case 4:
+					if ((cursor->info.is_file && vma->vm_file)||(!cursor->info.is_file && !vma->vm_file)) {
+						if (cursor->info.target_dev == *orig_dev &&
+							cursor->info.target_pgoff == *pgoff &&
+							((cursor->info.target_prot & VM_READ) == (*flags & VM_READ) &&
+							 (cursor->info.target_prot & VM_WRITE) == (*flags & VM_WRITE) &&
+							 (cursor->info.target_prot & VM_EXEC) == (*flags & VM_EXEC) &&
+							 (cursor->info.target_prot & VM_MAYSHARE) == (*flags & VM_MAYSHARE)) &&
+							  cursor->info.target_addr_size == target_addr_size) {
+							goto do_spoof;
+						}
+					}
+					break;
+				default:
+					break;
+			}
+		}
+		continue;
+do_spoof:
+		if (cursor->info.need_to_spoof_pathname) {
+			strncpy(out_name, cursor->info.spoofed_pathname, SUSFS_MAX_LEN_PATHNAME-1);
+		}
+		if (cursor->info.need_to_spoof_ino) {
+			*orig_ino = cursor->info.spoofed_ino;
+		}
+		if (cursor->info.need_to_spoof_dev) {
+			*orig_dev = cursor->info.spoofed_dev;
+		}
+		if (cursor->info.need_to_spoof_prot) {
+			if (cursor->info.spoofed_prot & VM_READ) *flags |= VM_READ;
+			else *flags = ((*flags | VM_READ) ^ VM_READ);
+			if (cursor->info.spoofed_prot & VM_WRITE) *flags |= VM_WRITE;
+			else *flags = ((*flags | VM_WRITE) ^ VM_WRITE);
+			if (cursor->info.spoofed_prot & VM_EXEC) *flags |= VM_EXEC;
+			else *flags = ((*flags | VM_EXEC) ^ VM_EXEC);
+			if (cursor->info.spoofed_prot & VM_MAYSHARE) *flags |= VM_MAYSHARE;
+			else *flags = ((*flags | VM_MAYSHARE) ^ VM_MAYSHARE);
+		}
+		if (cursor->info.need_to_spoof_pgoff) {
+			*pgoff = cursor->info.spoofed_pgoff;
+		}
+		SUSFS_LOGI("spoofing maps -> is_statically: '%d', compare_mode: '%d', is_file: '%d', is_isolated_entry: '%d', prev_target_ino: '%lu', next_target_ino: '%lu', target_ino: '%lu', target_dev: '0x%x', target_pgoff: '0x%x', target_prot: '0x%x', target_addr_size: '0x%x', spoofed_pathname: '%s', spoofed_ino: '%lu', spoofed_dev: '0x%x', spoofed_pgoff: '0x%x', spoofed_prot: '0x%x'\n",
+		cursor->info.is_statically, cursor->info.compare_mode, cursor->info.is_file,
+		cursor->info.is_isolated_entry, cursor->info.prev_target_ino, cursor->info.next_target_ino,
+		cursor->info.target_ino, cursor->info.target_dev, cursor->info.target_pgoff,
+		cursor->info.target_prot, cursor->info.target_addr_size, cursor->info.spoofed_pathname,
+		cursor->info.spoofed_ino, cursor->info.spoofed_dev, cursor->info.spoofed_pgoff,
+		cursor->info.spoofed_prot);
+		return 2;
+	}
+	return 0;
+}
+
+/* @ This function only does the following:
+ *   1. Spoof the symlink name of a target_ino listed in /proc/self/map_files
+ * 
+ * @Note
+ * - It has limitation as there is no way to check which
+ *   vma address it belongs by passing dentry* only, so it just
+ *   checks for matched dentry* and its target_ino in sus_maps list,
+ *   then spoof the symlink name of the target_ino defined by user.
+ * - Also user cannot see the effects in map_files from other root session,
+ *   because it uses current->mm to compare the dentry, the only way to test
+ *   is to check within its own pid.
+ * - So the BEST practise here is:
+ *     Do NOT spoof the map entries which share the same name to different name
+ *     seperately unless the other spoofed name is empty of which spoofed_ino is 0,
+ *     otherwise there will be inconsistent entries between maps and map_files.
+ */
+void susfs_sus_map_files_readlink(unsigned long target_ino, char* pathname) {
+	struct st_susfs_sus_maps_list *cursor, *temp;
+
+	if (!pathname)
+		return;
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_MAPS_SPOOFER, list) {
+		// We are only interested in statically and target_ino > 0
+		if (cursor->info.is_statically && cursor->info.compare_mode > 0 &&
+			target_ino > 0 && cursor->info.target_ino == target_ino)
+		{
+			if (cursor->info.need_to_spoof_pathname) {
+				SUSFS_LOGI("spoofing symlink name of ino '%lu' to '%s' in map_files\n",
+						target_ino, cursor->info.spoofed_pathname);
+				// Don't need to check buffer size as 'pathname' is allocated with 'PAGE_SIZE'
+				// which is way bigger than SUSFS_MAX_LEN_PATHNAME
+				strcpy(pathname, cursor->info.spoofed_pathname);
+				return;
+			}
+		}
+	}
+	return;
+}
+
+/* @ This function mainly does the following:
+ *   1. Remove the user write access for spoofed symlink name in /proc/self/map_files
+ *   2. Prevent the dentry from being seen in /proc/self/map_files
+ * 
+ * @Note
+ * - anon files are supposed to be not shown in /proc/self/map_files and 
+ *   spoofing from memfd name to non-memfd name should not have write
+ *   permission on that target dentry
+ */
+int susfs_sus_map_files_instantiate(struct vm_area_struct* vma) {
+	struct inode *inode = file_inode(vma->vm_file);
+	unsigned long target_ino = inode->i_ino;
+	dev_t target_dev = inode->i_sb->s_dev;
+	unsigned long long target_pgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
+	unsigned long target_addr_size = vma->vm_end - vma->vm_start;
+	vm_flags_t target_flags = vma->vm_flags;
+	struct st_susfs_sus_maps_list *cursor, *temp;
+	struct inode *tmp_inode, *tmp_inode_prev, *tmp_inode_next;
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_MAPS_SPOOFER, list) {
+		// We are only interested in statically
+		if (!cursor->info.is_statically) {
+			continue;
+		// if it is statically, then compare with compare_mode
+		} else if (cursor->info.compare_mode > 0) {
+			switch(cursor->info.compare_mode) {
+				case 1:
+					if (target_ino != 0 && cursor->info.target_ino == target_ino) {
+						goto do_spoof;
+					}
+					break;
+				case 2:
+					if (target_ino != 0 && cursor->info.target_ino == target_ino &&
+						((cursor->info.target_prot & VM_READ) == (target_flags & VM_READ)) &&
+						((cursor->info.target_prot & VM_WRITE) == (target_flags & VM_WRITE)) &&
+						((cursor->info.target_prot & VM_EXEC) == (target_flags & VM_EXEC)) &&
+						((cursor->info.target_prot & VM_MAYSHARE) == (target_flags & VM_MAYSHARE)) &&
+						  cursor->info.target_addr_size == target_addr_size &&
+						  cursor->info.target_pgoff == target_pgoff) {
+						// if is NOT isolated_entry, check for vma->vm_next and vma->vm_prev to see if they have the same inode
+						if (!cursor->info.is_isolated_entry) {
+							if (vma && vma->vm_next) {
+								if (vma->vm_next->vm_file) {
+									tmp_inode = file_inode(vma->vm_next->vm_file);
+									if (tmp_inode->i_ino == cursor->info.target_ino)
+										goto do_spoof;
+								}
+							}
+							if (vma && vma->vm_prev) {
+								if (vma->vm_prev->vm_file) {
+									tmp_inode = file_inode(vma->vm_prev->vm_file);
+									if (tmp_inode->i_ino == cursor->info.target_ino)
+										goto do_spoof;
+								}
+							}
+							continue;
+						// if it is isolated_entry
+						} else {
+							if (vma && vma->vm_next) {
+								if (vma->vm_next->vm_file) {
+									tmp_inode = file_inode(vma->vm_next->vm_file);
+									if (tmp_inode->i_ino == cursor->info.target_ino) {
+										continue;
+									}
+								}
+							}
+							if (vma && vma->vm_prev) {
+								if (vma->vm_prev->vm_file) {
+									tmp_inode = file_inode(vma->vm_prev->vm_file);
+									if (tmp_inode->i_ino == cursor->info.target_ino) {
+										continue;
+									}
+								}
+							}
+							// both prev and next don't have the same indoe as current entry, we can spoof now
+							goto do_spoof;
+						}
+					}
+					break;
+				case 3:
+					// if current vma is a file, it is not our target
+					if (vma->vm_file) continue;
+					// compare next target ino only
+					if (cursor->info.prev_target_ino == 0 && cursor->info.next_target_ino > 0) {
+						if (vma->vm_next && vma->vm_next->vm_file) {
+							tmp_inode_next = file_inode(vma->vm_next->vm_file);
+							if (tmp_inode_next->i_ino == cursor->info.next_target_ino) {
+								goto do_spoof;
+							}
+						}
+					// compare prev target ino only
+					} else if (cursor->info.prev_target_ino > 0 && cursor->info.next_target_ino == 0) {
+						if (vma->vm_prev && vma->vm_prev->vm_file) {
+							tmp_inode_prev = file_inode(vma->vm_prev->vm_file);
+							if (tmp_inode_prev->i_ino == cursor->info.prev_target_ino) {
+								goto do_spoof;
+							}
+						}
+					// compare both prev ino and next ino
+					} else if (cursor->info.prev_target_ino > 0 && cursor->info.next_target_ino > 0) {
+						if (vma->vm_prev && vma->vm_prev->vm_file &&
+							vma->vm_next && vma->vm_next->vm_file) {
+							tmp_inode_prev = file_inode(vma->vm_prev->vm_file);
+							tmp_inode_next = file_inode(vma->vm_next->vm_file);
+							if (tmp_inode_prev->i_ino == cursor->info.prev_target_ino &&
+							    tmp_inode_next->i_ino == cursor->info.next_target_ino) {
+								goto do_spoof;
+							}
+						}
+					}
+					break;
+				case 4:
+					if ((cursor->info.is_file && vma->vm_file)||(!cursor->info.is_file && !vma->vm_file)) {
+						if (cursor->info.target_dev == target_dev &&
+							cursor->info.target_pgoff == target_pgoff &&
+							((cursor->info.target_prot & VM_READ) == (target_flags & VM_READ) &&
+							 (cursor->info.target_prot & VM_WRITE) == (target_flags & VM_WRITE) &&
+							 (cursor->info.target_prot & VM_EXEC) == (target_flags & VM_EXEC) &&
+							 (cursor->info.target_prot & VM_MAYSHARE) == (target_flags & VM_MAYSHARE)) &&
+							  cursor->info.target_addr_size == target_addr_size) {
+							goto do_spoof;
+						}
+					}
+					break;
+				default:
+					break;
+			}
+		}
+		continue;
+do_spoof:
+		if (!(cursor->info.spoofed_ino == 0 ||
+			(MAJOR(cursor->info.spoofed_dev) == 0 &&
+			(MINOR(cursor->info.spoofed_dev) == 0 || MINOR(cursor->info.spoofed_dev) == 1))))
+		{
+			SUSFS_LOGI("remove user write permission of spoofed symlink '%s' in map_files\n", cursor->info.spoofed_pathname);
+			return 1;
+		} else {
+			SUSFS_LOGI("drop dentry of target_ino '%lu' with spoofed_ino '%lu' in map_files\n",
+						cursor->info.target_ino, cursor->info.spoofed_ino);
+			return 2;
+		}
+		return 0;
+	}
+	return 0;
+}
+
+int susfs_is_sus_maps_list_empty(void) {
+	return list_empty(&LH_SUS_MAPS_SPOOFER);
+}
+
+int susfs_sus_proc_fd_link(char *pathname, int len) {
+	struct st_susfs_sus_proc_fd_link_list *cursor, *temp;
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_PROC_FD_LINK, list) {
+		if (unlikely(!strcmp(pathname, cursor->info.target_link_name))) {
+			SUSFS_LOGI("[uid:%u] spoofing fd link: '%s' -> '%s'\n", current_uid().val, pathname, cursor->info.spoofed_link_name);
+			memset(pathname, 0, len);
+			strcpy(pathname, cursor->info.spoofed_link_name);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+int susfs_is_sus_proc_fd_link_list_empty(void) {
+	return list_empty(&LH_SUS_PROC_FD_LINK);
+}
+
+int susfs_sus_memfd(char *memfd_name) {
+	struct st_susfs_sus_memfd_list *cursor, *temp;
+
+	list_for_each_entry_safe(cursor, temp, &LH_SUS_MEMFD, list) {
+		if (unlikely(!strcmp(memfd_name, cursor->info.target_pathname))) {
+			SUSFS_LOGI("prevent memfd_name: '%s' from being created\n", memfd_name);
+			return 1;
+		}
+	}
+    return 0;
+}
+
+static void umount_mnt(struct path *path, int flags) {
+	int err = path_umount(path, flags);
+	if (err) {
+		SUSFS_LOGI("umount %s failed: %d\n", path->dentry->d_iname, err);
+	}
+}
+
+static bool should_umount(struct path *path)
+{
+	if (!path) {
+		return false;
+	}
+
+	if (current->nsproxy->mnt_ns == init_nsproxy.mnt_ns) {
+		SUSFS_LOGI("ignore global mnt namespace process: %d\n",
+			current_uid().val);
+		return false;
+	}
+
+	if (path->mnt && path->mnt->mnt_sb && path->mnt->mnt_sb->s_type) {
+		const char *fstype = path->mnt->mnt_sb->s_type->name;
+		return strcmp(fstype, "overlay") == 0;
+	}
+	return false;
+}
+
+static void try_umount(const char *mnt, bool check_mnt, int flags) {
+	struct path path;
+	int err = kern_path(mnt, 0, &path);
+
+	if (err) {
+		return;
+	}
+
+	if (path.dentry != path.mnt->mnt_root) {
+		// it is not root mountpoint, maybe umounted by others already.
+		return;
+	}
+
+	// we are only interest in some specific mounts
+	if (check_mnt && !should_umount(&path)) {
+		return;
+	}
+	
+	umount_mnt(&path, flags);
+}
+
+void susfs_try_umount(uid_t target_uid) {
+	struct st_susfs_try_umount_list *cursor, *temp;
+
+	list_for_each_entry_safe(cursor, temp, &LH_TRY_UMOUNT_PATH, list) {
+		SUSFS_LOGI("umounting '%s' for uid: %d\n", cursor->info.target_pathname, target_uid);
+		if (cursor->info.mnt_mode == 0) {
+			try_umount(cursor->info.target_pathname, false, 0);
+		} else if (cursor->info.mnt_mode == 1) {
+			try_umount(cursor->info.target_pathname, false, MNT_DETACH);
+		}
+	}
+}
+
+void susfs_spoof_uname(struct new_utsname* tmp) {
+	if (strcmp(my_uname.sysname, "default")) {
+		memset(tmp->sysname, 0, __NEW_UTS_LEN);
+		strncpy(tmp->sysname, my_uname.sysname, __NEW_UTS_LEN);
+	}
+	if (strcmp(my_uname.nodename, "default")) {
+		memset(tmp->nodename, 0, __NEW_UTS_LEN);
+		strncpy(tmp->nodename, my_uname.nodename, __NEW_UTS_LEN);
+	}
+	if (likely(strcmp(my_uname.release, "default"))) {
+		memset(tmp->release, 0, __NEW_UTS_LEN);
+		strncpy(tmp->release, my_uname.release, __NEW_UTS_LEN);
+	}
+	if (likely(strcmp(my_uname.version, "default"))) {
+		memset(tmp->version, 0, __NEW_UTS_LEN);
+		strncpy(tmp->version, my_uname.version, __NEW_UTS_LEN);
+	}
+	if (strcmp(my_uname.machine, "default")) {
+		memset(tmp->machine, 0, __NEW_UTS_LEN);
+		strncpy(tmp->machine, my_uname.machine, __NEW_UTS_LEN);
+	}
+}
+
+void susfs_set_log(bool enabled) {
+	spin_lock(&susfs_spin_lock);
+	is_log_enable = enabled;
+	spin_unlock(&susfs_spin_lock);
+	if (is_log_enable) {
+		pr_info("susfs: enable logging to kernel");
+	} else {
+		pr_info("susfs: disable logging to kernel");
+	}
+}
+
+/* For files/directories in /sdcard/ but not in /sdcard/Android/data/, please delete it  
+ * by yourself
+ */
+void susfs_change_error_no_by_pathname(char* const pathname, int* const errno_to_be_changed, int const syscall_family) {
+	if (!strncmp(pathname, "/system/", 8)||
+		!strncmp(pathname, "/vendor/", 8)) {
+		switch(syscall_family) {
+			case SYSCALL_FAMILY_ALL_ENOENT:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_LINKAT_OLDNAME:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_RENAMEAT2_OLDNAME:
+				*errno_to_be_changed = -EXDEV;
+				return;
+			//case SYSCALL_FAMILY_RENAMEAT2_NEWNAME:
+			//	if (!strncmp(pathname, "/system/", 8)) {
+			//		*errno_to_be_changed = -EROFS;
+			//	} else {
+			//		*errno_to_be_changed = -EXDEV;
+			//	}
+			//	return;
+			default:
+				*errno_to_be_changed = -EROFS;
+				return;
+		}
+	} else if (!strncmp(pathname, "/storage/emulated/0/Android/data/", 33)) {
+		switch(syscall_family) {
+			case SYSCALL_FAMILY_ALL_ENOENT:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_MKNOD:
+				*errno_to_be_changed = -EACCES;
+				return;
+			case SYSCALL_FAMILY_MKDIRAT:
+				*errno_to_be_changed = -EACCES;
+				return;
+			case SYSCALL_FAMILY_RMDIR:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_UNLINKAT:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_SYMLINKAT_NEWNAME:
+				*errno_to_be_changed = -EACCES;
+				return;
+			case SYSCALL_FAMILY_LINKAT_OLDNAME:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_LINKAT_NEWNAME:
+				*errno_to_be_changed = -EXDEV;
+				return;
+			case SYSCALL_FAMILY_RENAMEAT2_OLDNAME:
+				*errno_to_be_changed = -EXDEV;
+				return;
+			case SYSCALL_FAMILY_RENAMEAT2_NEWNAME:
+				*errno_to_be_changed = -EXDEV;
+				return;
+			default:
+				*errno_to_be_changed = -ENOENT;
+				return;
+		}
+	} else if (!strncmp(pathname, "/dev/", 5)) {
+		switch(syscall_family) {
+			case SYSCALL_FAMILY_ALL_ENOENT:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_MKNOD:
+				*errno_to_be_changed = -EACCES;
+				return;
+			case SYSCALL_FAMILY_MKDIRAT:
+				*errno_to_be_changed = -EACCES;
+				return;
+			case SYSCALL_FAMILY_RMDIR:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_UNLINKAT:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_SYMLINKAT_NEWNAME:
+				*errno_to_be_changed = -EACCES;
+				return;
+			case SYSCALL_FAMILY_LINKAT_OLDNAME:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_LINKAT_NEWNAME:
+				*errno_to_be_changed = -EXDEV;
+				return;
+			case SYSCALL_FAMILY_RENAMEAT2_OLDNAME:
+				*errno_to_be_changed = -EXDEV;
+				return;
+			case SYSCALL_FAMILY_RENAMEAT2_NEWNAME:
+				*errno_to_be_changed = -EXDEV;
+				return;
+			default:
+				*errno_to_be_changed = -ENOENT;
+				return;
+		}
+	} else if (!strncmp(pathname, "/data/", 6)) {
+				switch(syscall_family) {
+			case SYSCALL_FAMILY_ALL_ENOENT:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_MKNOD:
+				*errno_to_be_changed = -EACCES;
+				return;
+			case SYSCALL_FAMILY_MKDIRAT:
+				*errno_to_be_changed = -EACCES;
+				return;
+			case SYSCALL_FAMILY_RMDIR:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_UNLINKAT:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_SYMLINKAT_NEWNAME:
+				*errno_to_be_changed = -EACCES;
+				return;
+			case SYSCALL_FAMILY_LINKAT_OLDNAME:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_LINKAT_NEWNAME:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_RENAMEAT2_OLDNAME:
+				*errno_to_be_changed = -ENOENT;
+				return;
+			case SYSCALL_FAMILY_RENAMEAT2_NEWNAME:
+				*errno_to_be_changed = -EXDEV;
+				return;
+			default:
+				*errno_to_be_changed = -ENOENT;
+				return;
+		}
+	}
+}
+
+/*
+static int susfs_get_cur_fd_counts() {
+	struct fdtable *files_table;
+    int fd_count = 0;
+
+	files_table = files_fdtable(current->files);
+	for (i = 0; i < files_table->max_fds; i++) {
+        if (files_table->fd[i] != NULL) {
+            fd_count++;
+        }
+    }
+	return fd_count;
+}
+*/
+
+static void susfs_my_uname_init(void) {
+	memset(&my_uname, 0, sizeof(struct st_susfs_uname));
+	strncpy(my_uname.sysname, "default", __NEW_UTS_LEN);
+	strncpy(my_uname.nodename, "default", __NEW_UTS_LEN);
+	strncpy(my_uname.release, "default", __NEW_UTS_LEN);
+	strncpy(my_uname.version, "default", __NEW_UTS_LEN);
+	strncpy(my_uname.machine, "default", __NEW_UTS_LEN);
+}
+
+void __init susfs_init(void) {
+	spin_lock_init(&susfs_spin_lock);
+	spin_lock_init(&susfs_mnt_id_recorder_spin_lock);
+	susfs_my_uname_init();
+}
+
+/* No module exit is needed becuase it should never be a loadable kernel module */
+//void __init susfs_exit(void)
diff --git a/include/linux/susfs.h b/include/linux/susfs.h
new file mode 100644
index 0000000000000..28371670e2ca0
--- /dev/null
+++ b/include/linux/susfs.h
@@ -0,0 +1,216 @@
+#ifndef KSU_SUSFS_H
+#define KSU_SUSFS_H
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/utsname.h>
+#include <linux/mount.h>
+
+/* shared with userspace ksu_susfs tool */
+#define CMD_SUSFS_ADD_SUS_PATH 0x55555
+#define CMD_SUSFS_ADD_SUS_MOUNT 0x55556
+#define CMD_SUSFS_ADD_SUS_KSTAT 0x55558
+#define CMD_SUSFS_UPDATE_SUS_KSTAT 0x55559
+#define CMD_SUSFS_ADD_TRY_UMOUNT 0x5555a
+#define CMD_SUSFS_SET_UNAME 0x5555b
+#define CMD_SUSFS_ADD_SUS_KSTAT_STATICALLY 0x5555c
+#define CMD_SUSFS_ENABLE_LOG 0x5555d
+#define CMD_SUSFS_ADD_SUS_MAPS_STATICALLY 0x5555e
+#define CMD_SUSFS_ADD_SUS_PROC_FD_LINK 0x5555f
+#define CMD_SUSFS_ADD_SUS_MAPS 0x55560
+#define CMD_SUSFS_UPDATE_SUS_MAPS 0x55561
+#define CMD_SUSFS_ADD_SUS_MEMFD 0x55562
+
+#define SUSFS_MAX_LEN_PATHNAME 256 // 256 should address many paths already unless you are doing some strange experimental stuff, then set your own desired length
+#define SUSFS_MAX_LEN_MFD_NAME 248
+#define SUSFS_MAX_SUS_MNTS 300 // I think 300 is now enough? This includes the mount entries for each process and sus mounts added by user 
+#define SUSFS_MAX_SUS_MAPS 200 // I think 200 is now enough? Tell me why if you have over 200 entries
+
+#define SUSFS_MAP_FILES_ACTION_REMOVE_WRITE_PERM 1
+#define SUSFS_MAP_FILES_ACTION_HIDE_DENTRY 2
+
+/* non shared to userspace ksu_susfs tool */
+#define SYSCALL_FAMILY_ALL_ENOENT 0
+#define SYSCALL_FAMILY_OPENAT 1
+#define SYSCALL_FAMILY_MKNOD 2
+#define SYSCALL_FAMILY_MKDIRAT 3
+#define SYSCALL_FAMILY_RMDIR 4
+#define SYSCALL_FAMILY_UNLINKAT 5
+#define SYSCALL_FAMILY_SYMLINKAT_NEWNAME 6
+#define SYSCALL_FAMILY_LINKAT_OLDNAME 7
+#define SYSCALL_FAMILY_LINKAT_NEWNAME 8
+#define SYSCALL_FAMILY_RENAMEAT2_OLDNAME 9
+#define SYSCALL_FAMILY_RENAMEAT2_NEWNAME 10
+#define SYSCALL_FAMILY_TRUNCATE 11
+#define SYSCALL_FAMILY_FACCESSAT 12
+#define SYSCALL_FAMILY_CHDIR 13
+
+#define getname_safe(name) (name == NULL ? ERR_PTR(-EINVAL) : getname(name))
+#define putname_safe(name) (IS_ERR(name) ? NULL : putname(name))
+
+#define uid_matches_suspicious_path() (current_uid().val >= 2000)
+#define uid_matches_suspicious_kstat() (current_uid().val >= 2000)
+#define uid_matches_proc_need_to_reorder_mnt_id() (current_uid().val >= 10000)
+
+struct st_susfs_sus_path {
+	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
+	unsigned long           target_ino;
+};
+
+struct st_susfs_sus_mount {
+	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
+};
+
+struct st_susfs_sus_kstat {
+	unsigned long           target_ino; // the ino after bind mounted or overlayed
+	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
+	char                    spoofed_pathname[SUSFS_MAX_LEN_PATHNAME];
+	unsigned long           spoofed_ino;
+	unsigned long           spoofed_dev;
+	unsigned int            spoofed_nlink;
+	long                    spoofed_atime_tv_sec;
+	long                    spoofed_mtime_tv_sec;
+	long                    spoofed_ctime_tv_sec;
+	long                    spoofed_atime_tv_nsec;
+	long                    spoofed_mtime_tv_nsec;
+	long                    spoofed_ctime_tv_nsec;
+};
+
+struct st_susfs_sus_maps {
+	bool                    is_statically;
+	int                     compare_mode;
+	bool                    is_isolated_entry;
+	bool                    is_file;
+	unsigned long           prev_target_ino;
+	unsigned long           next_target_ino;
+	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
+	unsigned long           target_ino;
+	unsigned long           target_dev;
+	unsigned long long      target_pgoff;
+	unsigned long           target_prot;
+	unsigned long           target_addr_size;
+	char                    spoofed_pathname[SUSFS_MAX_LEN_PATHNAME];
+	unsigned long           spoofed_ino;
+	unsigned long           spoofed_dev;
+	unsigned long long      spoofed_pgoff;
+	unsigned long           spoofed_prot;
+	bool                    need_to_spoof_pathname;
+	bool                    need_to_spoof_ino;
+	bool                    need_to_spoof_dev;
+	bool                    need_to_spoof_pgoff;
+	bool                    need_to_spoof_prot;
+};
+
+struct st_susfs_try_umount {
+	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
+	int                     mnt_mode;
+};
+
+struct st_susfs_sus_proc_fd_link {
+	char                    target_link_name[SUSFS_MAX_LEN_PATHNAME];
+	char                    spoofed_link_name[SUSFS_MAX_LEN_PATHNAME];
+};
+
+struct st_susfs_sus_memfd {
+	char                    target_pathname[SUSFS_MAX_LEN_MFD_NAME];
+};
+
+struct st_susfs_mnt_id_recorder {
+	int                     target_mnt_id[SUSFS_MAX_SUS_MNTS];
+	int                     spoofed_mnt_id[SUSFS_MAX_SUS_MNTS];
+	int                     spoofed_parent_mnt_id[SUSFS_MAX_SUS_MNTS];
+	int                     count;
+};
+
+struct st_susfs_sus_path_list {
+	struct list_head                        list;
+	struct st_susfs_sus_path                info;
+};
+
+struct st_susfs_sus_mount_list {
+	struct list_head                        list;
+	struct st_susfs_sus_mount               info;
+};
+
+struct st_susfs_sus_kstat_list {
+	struct list_head                        list;
+	struct st_susfs_sus_kstat               info;
+};
+
+struct st_susfs_sus_maps_list {
+	struct list_head                        list;
+	struct st_susfs_sus_maps                info;
+};
+
+struct st_susfs_try_umount_list {
+	struct list_head                        list;
+	struct st_susfs_try_umount              info;
+};
+
+struct st_susfs_sus_proc_fd_link_list {
+	struct list_head                        list;
+	struct st_susfs_sus_proc_fd_link        info;
+};
+
+struct st_susfs_sus_memfd_list {
+	struct list_head                        list;
+	struct st_susfs_sus_memfd               info;
+};
+
+struct st_susfs_mnt_id_recorder_list {
+	struct list_head                        list;
+	int                                     pid;
+	int                                     opened_count;
+	struct st_susfs_mnt_id_recorder         info;
+};
+
+struct st_susfs_uname {
+	char        sysname[__NEW_UTS_LEN+1];
+	char        nodename[__NEW_UTS_LEN+1];
+	char        release[__NEW_UTS_LEN+1];
+	char        version[__NEW_UTS_LEN+1];
+	char        machine[__NEW_UTS_LEN+1];
+};
+
+int susfs_add_sus_path(struct st_susfs_sus_path* __user user_info);
+int susfs_add_sus_mount(struct st_susfs_sus_mount* __user user_info);
+int susfs_add_sus_kstat(struct st_susfs_sus_kstat* __user user_info);
+int susfs_update_sus_kstat(struct st_susfs_sus_kstat* __user user_info);
+int susfs_add_sus_maps(struct st_susfs_sus_maps* __user user_info);
+int susfs_update_sus_maps(struct st_susfs_sus_maps* __user user_info);
+int susfs_add_sus_proc_fd_link(struct st_susfs_sus_proc_fd_link* __user user_info);
+int susfs_add_sus_memfd(struct st_susfs_sus_memfd* __user user_info);
+int susfs_add_try_umount(struct st_susfs_try_umount* __user user_info);
+int susfs_set_uname(struct st_susfs_uname* __user user_info);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,19,0)
+int susfs_sus_path_by_path(struct path* file, int* errno_to_be_changed, int syscall_family);
+#else
+int susfs_sus_path_by_path(const struct path* file, int* errno_to_be_changed, int syscall_family);
+#endif
+int susfs_sus_path_by_filename(struct filename* name, int* errno_to_be_changed, int syscall_family);
+int susfs_sus_mount(struct vfsmount* mnt, struct path* root);
+int susfs_sus_ino_for_filldir64(unsigned long ino);
+void susfs_sus_kstat(unsigned long ino, struct stat* out_stat);
+int susfs_sus_maps(unsigned long target_ino, unsigned long target_addr_size,
+					unsigned long* orig_ino, dev_t* orig_dev, vm_flags_t* flags,
+					unsigned long long* pgoff, struct vm_area_struct* vma, char* out_name);
+void susfs_sus_map_files_readlink(unsigned long target_ino, char* pathname);
+int susfs_sus_map_files_instantiate(struct vm_area_struct* vma);
+int susfs_is_sus_maps_list_empty(void);
+int susfs_sus_proc_fd_link(char *pathname, int len);
+int susfs_is_sus_proc_fd_link_list_empty(void);
+int susfs_sus_memfd(char *memfd_name);
+void susfs_try_umount(uid_t target_uid);
+void susfs_spoof_uname(struct new_utsname* tmp);
+void susfs_add_mnt_id_recorder(struct mnt_namespace *ns);
+int susfs_get_fake_mnt_id(int mnt_id, int *out_mnt_id, int *out_parent_mnt_id);
+void susfs_remove_mnt_id_recorder(void);
+
+void susfs_set_log(bool enabled);
+
+void susfs_change_error_no_by_pathname(char* pathname, int* errno_to_be_changed, int syscall_family);
+
+void __init susfs_init(void);
+
+#endif
diff --git a/kernel/sys.c b/kernel/sys.c
index 03eb79776627e..65cfba3065e79 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -76,6 +76,10 @@
 
 #include "uid16.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 #include <trace/hooks/sys.h>
 
 #ifndef SET_UNALIGN_CTL
@@ -1266,6 +1270,9 @@ SYSCALL_DEFINE1(newuname, struct new_utsname __user *, name)
 	down_read(&uts_sem);
 	memcpy(&tmp, utsname(), sizeof(tmp));
 	up_read(&uts_sem);
+#ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
+	susfs_spoof_uname(&tmp);
+#endif
 	if (copy_to_user(name, &tmp, sizeof(tmp)))
 		return -EFAULT;
 
diff --git a/mm/memfd.c b/mm/memfd.c
index fae4142f7d254..093d9b041d46b 100644
--- a/mm/memfd.c
+++ b/mm/memfd.c
@@ -20,6 +20,10 @@
 #include <linux/memfd.h>
 #include <uapi/linux/memfd.h>
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 /*
  * We need a tag: a new tag would expand every xa_node by 8 bytes,
  * so reuse a tag which we firmly believe is never set or cleared on tmpfs
@@ -306,6 +310,13 @@ SYSCALL_DEFINE2(memfd_create,
 		goto err_name;
 	}
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MEMFD
+	if (susfs_sus_memfd(name)) {
+		error = -EFAULT;
+		goto err_name;
+	}
+#endif
+
 	fd = get_unused_fd_flags((flags & MFD_CLOEXEC) ? O_CLOEXEC : 0);
 	if (fd < 0) {
 		error = fd;
